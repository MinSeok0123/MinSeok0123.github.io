{"componentChunkName":"component---src-templates-post-template-tsx","path":"/그리디 알고리즘/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2 id=\"그리디-알고리즘-개념\" style=\"position:relative;\">그리디 알고리즘 개념<a href=\"#%EA%B7%B8%EB%A6%AC%EB%94%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B0%9C%EB%85%90\" aria-label=\"그리디 알고리즘 개념 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>그리디 알고리즘(탐욕법)은 <strong>현재 상황에서 지금 당장 좋은 것만</strong> 고르는 방법을 의미한다.\n<strong>일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다.</strong></p>\n<h3 id=\"작동-방식\" style=\"position:relative;\">작동 방식<a href=\"#%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\" aria-label=\"작동 방식 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그리디 알고리즘은 다음과 같은 단계로 동작합니다.</p>\n<ol>\n<li>문제를 하위 문제로 나눕니다.</li>\n<li>각 하위 문제에 대해 가장 좋아 보이는 선택을 합니다.</li>\n<li>선택한 해를 부분해 집합에 추가합니다.</li>\n<li>부분해 집합이 최종 해답이 되는지 확인합니다.</li>\n<li>만약 최종 해답이 아니라면, 2단계로 돌아가 반복합니다.</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/da8b64eb-e2fc-47fb-99b5-5f2413e4f365/image.png\" alt=\"\"></p>\n<h3 id=\"장단점\" style=\"position:relative;\">장단점<a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90\" aria-label=\"장단점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>그리디 알고리즘의 주요 장점은 다음과 같습니다.</p>\n<ol>\n<li>구현이 비교적 간단하다.</li>\n<li>실행 속도가 빠르다.</li>\n</ol>\n<p>하지만 그리디 알고리즘은 항상 최적해를 구할 수 있는 것은 아닙니다. 최적해를 보장하기 위해서는 추가적인 검증 단계가 필요할 수 있습니다. 그리디 알고리즘은 각 단계에서의 선택이 최적일 뿐, 그 선택들이 전체적으로 최적인지 보장하지 않기 때문입니다. 따라서 그리디 알고리즘을 사용할 때에는 문제의 성질과 제약 조건을 분석하여 최적해를 보장할 수 있는지 판단해야 합니다.</p>\n<h2 id=\"예시\" style=\"position:relative;\">예시<a href=\"#%EC%98%88%EC%8B%9C\" aria-label=\"예시 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"문제-거스름돈-문제\" style=\"position:relative;\">문제: 거스름돈 문제<a href=\"#%EB%AC%B8%EC%A0%9C-%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88-%EB%AC%B8%EC%A0%9C\" aria-label=\"문제 거스름돈 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리의 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.</p>\n</blockquote>\n<h4 id=\"해결-방법\" style=\"position:relative;\">해결 방법:<a href=\"#%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95\" aria-label=\"해결 방법 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>동전의 최소 개수를 구해야 하는 문제이기 때문에, <strong>가장 큰 화폐 단위부터 돈을 거슬러 주는 것</strong>입니다.</p>\n<p>거스름 돈이 N원일 때, <code class=\"language-text\">500원</code>으로 최대한 많이 거슬러주고, 순서대로 <code class=\"language-text\">100원</code>, <code class=\"language-text\">50원</code>, <code class=\"language-text\">10원</code>을 써서 거슬러주면 됩니다.</p>\n<p>이제 N이 1,260 일 때의 예시를 확인해봅시다.</p>\n<h1 id=\"코드\" style=\"position:relative;\">코드<a href=\"#%EC%BD%94%EB%93%9C\" aria-label=\"코드 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h>\n\nvoid giveChange(int amount) {\n    int coins[] = {500, 100, 50, 10};  // 동전 종류\n    int numCoins = sizeof(coins) / sizeof(coins[0]);  // 동전 종류의 개수\n    int count[numCoins];  // 동전 개수를 저장할 배열\n\n    // 각 동전의 개수 초기화\n    for (int i = 0; i &lt; numCoins; i++) {\n        count[i] = 0;\n    }\n\n    // 가장 큰 동전부터 시작하여 거스름돈 주기\n    for (int i = 0; i &lt; numCoins; i++) {\n        while (amount >= coins[i]) {\n            amount -= coins[i];\n            count[i]++;\n        }\n    }\n\n    // 거스름돈 출력\n    for (int i = 0; i &lt; numCoins; i++) {\n        if (count[i] > 0) {\n            printf(\"%d원 동전: %d개\\n\", coins[i], count[i]);\n        }\n    }\n}\n\nint main() {\n    int amount = 1260;  // 거스름돈 금액\n    giveChange(amount);\n    return 0;\n}\n</code></pre></div>\n<h1 id=\"정당성-분석\" style=\"position:relative;\">정당성 분석<a href=\"#%EC%A0%95%EB%8B%B9%EC%84%B1-%EB%B6%84%EC%84%9D\" aria-label=\"정당성 분석 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요?</p>\n<ul>\n<li>가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문</li>\n</ul>\n<p>Q) 만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500원, 400원, 100원이라면 어떻게 될까요?</p>\n<ul>\n<li>4개의 동전 / 2개의 동전</li>\n</ul>\n<p><strong>대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수있어야 답을 도출할 수 있다.</strong></p>","frontmatter":{"title":"그리디 알고리즘","summary":"그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.","date":"2023.05.11","categories":["알고리즘","C"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#585858","images":{"fallback":{"src":"/static/cdd912ffc0119bc7769fc61a1db10078/dccd3/greedy.webp","srcSet":"/static/cdd912ffc0119bc7769fc61a1db10078/09d71/greedy.webp 320w,\n/static/cdd912ffc0119bc7769fc61a1db10078/359e0/greedy.webp 640w,\n/static/cdd912ffc0119bc7769fc61a1db10078/dccd3/greedy.webp 1280w","sizes":"(min-width: 1280px) 1280px, 100vw"},"sources":[]},"width":1280,"height":800}},"publicURL":"/static/cdd912ffc0119bc7769fc61a1db10078/greedy.png"}}}}]}},"pageContext":{"slug":"/그리디 알고리즘/"}},"staticQueryHashes":[],"slicesMap":{}}