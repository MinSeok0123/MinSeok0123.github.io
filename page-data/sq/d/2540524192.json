{"data":{"allMarkdownRemark":{"nodes":[{"id":"8c0f6337-037a-5f8f-96a9-db46ceccf70e","excerpt":"ESP8266이란? ESP8266은 Wi-Fi 모듈로, 저렴하고 매우 강력한 기능을 가지고 있습니다. 이 모듈은 고성능 마이크로컨트롤러와 Wi-Fi 기능을 하나의 칩에 통합한 것입니다. ESP8266 모듈은 TCP/IP 스택을 내장하여 인터넷에 직접 연결할 수 있으며, Wi-Fi로 인터넷 연결을 지원합니다. ESP8266의 특징 1 .저렴하고 소형이며 경제적인 전력 소비 2. Wi-Fi 연결을 지원 3. 안정적인 TCP/IP 스택 내장…","fields":{"slug":"/ESP8266에 관하여/"},"frontmatter":{"title":"ESP8266에 관하여","date":"2023.04.30","thumbnail":{"publicURL":"/static/17e9e1bda5eeb18bdf00ffb03a9c155b/esp8266.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACOUlEQVR42mP4TwFgoK3mv3///v337+/fv6Rp/vf/399/f6FMKPmPKM3/YLZdu3F9waKefYf2ggX//vv3j4BmkDawmmOnj3kE+Fjamnj7mp85Mev//z///v2HOQdD8z8w+P///+u3r7om9jh6usxZ2PHwwc4TR+fNnhI2Y2r2u3cvIcpQNMPd+efPn/1HDgZFR5pY6i9Z2vri2b4nj3a9fXVw356ZQZE+0UmRN29dhKhngLsTYtjDxw/bezuNra0cHcxion1q6tOOH1927/b27Zvbiov8HFztNfW0du5aBtYMthmi7du3rxu3bAwID9Ex1HNyd01Iic7KSXJwsU9KDpjQmx4f7+Xg5haTGLdwyaw/f39C3MoA0Xnj+rnAYD9rB1tjMxNfP7fM7MTo+Gg9I4PCoixvP3cHZ9u45JSC0vy29spHT65Bgg3kZ0jAL1vcGx8fEp8Ua2RqFBDo4+3n6u/n6ebsoKCiZG5pkZ2XXVqe29FZcf3GiT9/f8BjC2rzly8fFiyYfPr00Z4J3bra6n6uDhZmRoZ6Oo4ujiWlBWVlWUuWTHr//gmuFPb38ZNrV68dnz6jJzk5xs/HU0VdLT0ztaw8r6429/jxbX/+focEEhbN//79/fzlzakzeydMbC4qSFZQlLS2syory548uenps5uQMEXTiZZI/n399v7mnfNz5rR2tWd1dddu3770x48P8OggmDH+/fz15f2HJ/cfXnrx8v5fcJTg0IgzbcNyz7+BLQzwaAYAYqX0bt12wf0AAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/17e9e1bda5eeb18bdf00ffb03a9c155b/46604/esp8266.png","srcSet":"/static/17e9e1bda5eeb18bdf00ffb03a9c155b/62d80/esp8266.png 125w,\n/static/17e9e1bda5eeb18bdf00ffb03a9c155b/e1953/esp8266.png 250w,\n/static/17e9e1bda5eeb18bdf00ffb03a9c155b/46604/esp8266.png 500w,\n/static/17e9e1bda5eeb18bdf00ffb03a9c155b/d8815/esp8266.png 750w,\n/static/17e9e1bda5eeb18bdf00ffb03a9c155b/31987/esp8266.png 1000w,\n/static/17e9e1bda5eeb18bdf00ffb03a9c155b/40a76/esp8266.png 1360w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["ESP8266","Arduino","임베디드"]},"rawMarkdownBody":"\n# ESP8266이란?\n\nESP8266은 Wi-Fi 모듈로, 저렴하고 매우 강력한 기능을 가지고 있습니다. 이 모듈은 고성능 마이크로컨트롤러와 Wi-Fi 기능을 하나의 칩에 통합한 것입니다. ESP8266 모듈은 TCP/IP 스택을 내장하여 인터넷에 직접 연결할 수 있으며, Wi-Fi로 인터넷 연결을 지원합니다.\n\n# ESP8266의 특징\n\n1 .저렴하고 소형이며 경제적인 전력 소비 2. Wi-Fi 연결을 지원 3. 안정적인 TCP/IP 스택 내장 4. AT 명령어를 통한 제어 가능 5. 개발 도구 및 라이브러리가 많음 6. Arduino IDE와 함께 사용 가능\n\n## ESP8266을 사용하는 방법\n\nESP8266 모듈은 AT 명령어를 통해 제어할 수 있습니다. AT 명령어는 모듈에서 사용할 수 있는 명령어를 나타냅니다. ESP8266 모듈은 AT 명령어를 사용하여 Wi-Fi 연결, 인터넷 통신 등을 수행할 수 있습니다. 또한 Arduino IDE를 사용하여 ESP8266을 쉽게 제어할 수 있습니다.\n\nESP8266 모듈을 사용하여 IoT 기기를 개발하는 경우, ESP8266 모듈을 사용하여 Wi-Fi 연결 및 데이터 전송 기능을 구현할 수 있습니다. 이를 위해 ESP8266 모듈과 다른 센서 및 장치를 연결하여 데이터를 수집하고 처리하는 코드를 작성해야 합니다.\n\n## ESP8266을 활용한 프로젝트\n\n1. 스마트 홈 제어 시스템\n2. 날씨 예보 및 알림 시스템\n3. 원격 제어 및 모니터링 시스템\n4. IoT 기반 스마트 농업 시스템\n5. Wi-Fi를 활용한 센서 네트워크 구축\n"},{"id":"fec65332-50ca-555c-8362-439ad33e3857","excerpt":"아래는 PyDub 라이브러리를 사용하여 음성 파일을 자동으로 분리하고 무음을 제거하는 Python 코드입니다. diff-svc 음성파일을 더 쉽게 만들기 위해 제작하였습니다. PyDub을 사용한 음성 파일 분리 및 무음 제거 개요 이번 포스트에서는 Python 라이브러리인 PyDub을 사용하여 음성 파일을 전처리하는 방법을 알아보겠습니다. PyDub은 오디오 파일의 다양한 처리 작업을 수행할 수 있는 라이브러리로, 간단한 API…","fields":{"slug":"/diff-svc 음성파일 (전처리)만드는 법/"},"frontmatter":{"title":"diff-svc 음성파일 (전처리)만드는 법","date":"2023.04.21","thumbnail":{"publicURL":"/static/84fafe303a969987ed1f8a59457a80e6/diffsvc.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvElEQVR42k3QTSsEYBQF4CcZdppSKJIyKRZqIiQaZkYaHymNj6ZZMIuxsFPyA/xx3ZzF3MX7dc4997wH3nCKE3RxjD7usYF5DLCHVxxiIfwjPGLVf83VcpvLEFcY4Qe/WA+psCU0wtnCGGdo4sBMDbP3cBmXF3G5jE2s4Bnn6EToBWvYCXeKdgndRLAb+wXu5muNnM0MLfwbLVwnohr6hc8ifUSssnzCBHd5q1rEQ3KueLbxHmyQnnai2v8DPXgVhKA+pTcAAAAASUVORK5CYII=","aspectRatio":3.676470588235294,"src":"/static/84fafe303a969987ed1f8a59457a80e6/46604/diffsvc.png","srcSet":"/static/84fafe303a969987ed1f8a59457a80e6/62d80/diffsvc.png 125w,\n/static/84fafe303a969987ed1f8a59457a80e6/e1953/diffsvc.png 250w,\n/static/84fafe303a969987ed1f8a59457a80e6/46604/diffsvc.png 500w,\n/static/84fafe303a969987ed1f8a59457a80e6/d8815/diffsvc.png 750w,\n/static/84fafe303a969987ed1f8a59457a80e6/31987/diffsvc.png 1000w,\n/static/84fafe303a969987ed1f8a59457a80e6/a4fbc/diffsvc.png 1213w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["Python","diff-svc"]},"rawMarkdownBody":"\n아래는 PyDub 라이브러리를 사용하여 음성 파일을 자동으로 분리하고 무음을 제거하는 Python 코드입니다. diff-svc 음성파일을 더 쉽게 만들기 위해 제작하였습니다.\n\n# PyDub을 사용한 음성 파일 분리 및 무음 제거\n\n## 개요\n\n이번 포스트에서는 Python 라이브러리인 PyDub을 사용하여 음성 파일을 전처리하는 방법을 알아보겠습니다. PyDub은 오디오 파일의 다양한 처리 작업을 수행할 수 있는 라이브러리로, 간단한 API와 함께 사용하기 쉽습니다. 이번 포스트에서는 PyDub을 사용하여 음성 파일을 무음 구간을 기준으로 분리하고, 분리된 오디오 조각들을 최대 15초까지만 선택하여 WAV 파일로 저장하고, 마지막으로 무음을 제거하는 작업을 수행하는 코드를 살펴보겠습니다.\n\n### 들어가기에 앞서 아래코드는 pydub 라이브러리가 필요합니다.\n\n파이썬 2.7, 3.3 이상의 버전에서 사용 가능합니다. pydub를 설치하려면 pip를 사용합니다.\n\n```\npip install pydub\n\n```\n\n## 코드\n\n먼저 필요한 라이브러리를 import합니다.\n\n```\nfrom pydub import AudioSegment\nfrom pydub.silence import split_on_silence\nimport os\nimport subprocess\n\n```\n\n다음으로, 입력 파일 경로와 출력 폴더를 설정합니다.\n\n```\ninput_file = 'input_file.mp3'\noutput_folder = 'output_folder'\n\n```\n\n이제, 입력 파일을 PyDub으로 로드하고, 샘플링 레이트, 채널, 샘플 넓이를 설정합니다.\n\n```\nsound = AudioSegment.from_file(input_file)\nsound = sound.set_frame_rate(44100).set_channels(1).set_sample_width(2)\n\n```\n\n이제, PyDub의 split_on_silence() 함수를 사용하여 입력된 음성 파일을 무음을 기준으로 자동으로 분리합니다. 이 함수는 최소 무음 길이, 무음으로 간주되는 dBFS 값, 분리된 각 음성 조각들 간의 추가적인 무음 길이를 인자로 받습니다.\n\n```\naudio_chunks = split_on_silence(sound,\n    min_silence_len=1000, # 최소 무음 길이 (밀리초 단위)\n    silence_thresh=-35, # 무음으로 간주되는 dBFS 값\n    keep_silence=500 # 분리된 오디오 조각들 간의 추가적인 무음 길이 (밀리초 단위)\n)\n\n```\n\n분리된 음성 조각들 중 최대 15초까지만 선택하여 WAV 파일로 저장합니다.\n이 작업은 각 음성의 길이가 너무 긴 경우 파일 크기가 너무 커지는 것을 방지하기 위한 것입니다.\n\n```\nfor i, chunk in enumerate(audio_chunks):\n    if len(chunk) > 15000:\n        chunk = chunk[:15000]\n    output_file = os.path.join(output_folder, f'chunk_{i}.wav')\n    chunk.export(output_file, format='wav')\n\n```\n\n마지막으로 무음제거 코드입니다.\n\n```\nfor filename in os.listdir(output_folder):\n    if filename.endswith('.wav'):\n        input_path = os.path.join(output_folder, filename)\n        output_path = os.path.join(output_folder, f'processed_{filename}')\n        subprocess.call(['ffmpeg', '-i', input_path, '-af', 'silenceremove=1:0:-50dB', '-y', output_path])\n        os.remove(input_path)\n```\n\n# 전체코드\n\n```\nfrom pydub import AudioSegment\nfrom pydub.silence import split_on_silence\nimport os\nimport subprocess\n\n# 음성파일 경로 설정\ninput_file = 'input_file.mp3'\noutput_folder = 'output_folder'\n\n# 오디오 파일 로드 및 변환\nsound = AudioSegment.from_file(input_file)\nsound = sound.set_frame_rate(44100).set_channels(1).set_sample_width(2)\n\n# 무음 구간을 기준으로 오디오 파일 분리\naudio_chunks = split_on_silence(sound,\n    min_silence_len=1000, # 최소 무음 길이 (밀리초 단위)\n    silence_thresh=-35, # 무음으로 간주되는 dBFS 값\n    keep_silence=500 # 분리된 오디오 조각들 간의 추가적인 무음 길이 (밀리초 단위)\n)\n\n# 출력 파일명 설정 및 출력 폴더 생성\nif not os.path.exists(output_folder):\n    os.makedirs(output_folder)\n\n# 분리된 오디오 조각들 중 최대 15초까지만 선택하여 wav 파일로 저장\nfor i, chunk in enumerate(audio_chunks):\n    if len(chunk) > 15000:\n        chunk = chunk[:15000]\n    output_file = os.path.join(output_folder, f'chunk_{i}.wav')\n    chunk.export(output_file, format='wav')\n\n# 무음 제거\nfor filename in os.listdir(output_folder):\n    if filename.endswith('.wav'):\n        input_path = os.path.join(output_folder, filename)\n        output_path = os.path.join(output_folder, f'processed_{filename}')\n        subprocess.call(['ffmpeg', '-i', input_path, '-af', 'silenceremove=1:0:-50dB', '-y', output_path])\n        os.remove(input_path)\n\n```\n"},{"id":"8d3dbfa5-b2c0-5cf5-9607-2eb30a58de2c","excerpt":"프로젝트명 스마트팜 Great Brain 제품 설명 나만의 작은 스마트팜 “하드웨어와 소프트웨어로 완벽한 식물을 기른다.” 토양 수분 센서를 이용해 토양 수분 확인 토양수분 센서를 흙에 꽃아 흙의 수분양을 파악 자동으로 펌프를 이용해서 수분공급 토양수분 센서로 인식된 값이 일정 수준보다 낮을 때 자동으로 수분을 공급 식물 관리를 위한 앱 현재 수분/ 습도/ 광량을 앱에서 모니터링 및 수동 제어 가능 💡 자세한 것은 GitHub…","fields":{"slug":"/ESP8266으로 만든 스마트팜/"},"frontmatter":{"title":"ESP8266으로 만든 스마트팜","date":"2021.10.19","thumbnail":{"publicURL":"/static/ffd913ea2c0d67b777d7e1310e8ad91e/gb.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADNUlEQVR42l3O20+TdwDG8fcP2NUSd7EEGQhYoQXachqnYoFSKC1dy8nSlrZAKSOiMBUzwMF2MY2MMZQgui2bIZnGRV1YyA6yZQcJiclgUyxTGQ4jQhlE3Ryve5ffdxlXy75Xz9WTj1RZ2/jE6vT8rc3c/VeiLk9R6/MVVUq2otKkK1GxaiUY8ConjrYrk5dOK5MXR5WJjwaVifPDyszUVWUxfEsJz8wq4dlZ5db1OeWry+OKpMu1PNVmm9iRqCc6Lon4RC2xqlSid6iISdDQ2NREc52ZT8cGmBg7xoXRbr64cJKZH65xY26O//bg13tIRqtPNtmDpOfZhTajWOizTEKTli+e375TRMXuEk6XTwSqC0X/G10ix/K60Ba/KboPHhR378yJ5fsR8c21c+LjzwYEIJZuLwjJ5joge0K9GM3VQpdhIiu7FHVqGsk6NdoMDQ5fC+7qMvINJTwTU8+zcQ1YjBYeP4xsqTqHXsR2SGLq+iVWFpeRnHVBua65nczyBrHTFCD5pXYyXX501T6SCswUO0NUmAtoa93PvsMncFaU8trLNWxE1ljbWKb+SBSOTonpuU9YXVxB6ul7R67qG6V8Zl10/PQ79qk/KPr8Ebu/XMMzeIUDfecwG3No9noZPvs9fl89vR1uHm2ssylv0vl2JmPjPVvaxfmfkSzOkGzd203Oq4PC2HyE8n39qP1dRFftRV/hx+o5TKmpEKelnOMj49RWOdkfsPFbZGXr5OqNDwgvTG/tX27OI1mrQvLRgbM4vB3C4GjAWNlCkSNAVn45CfEq9OlGDLm5WMts9L51ngprGY17TKyvrRKJRPju2ykmr3zNk80/Wbp9B8ls98nuYC/+YJ/IK6yjqKwJdZKBhDgtu1RaUpPTKDHmEaz30tbeRa3dRNBVwuqD+2w+lZldmubm0o9bwoXwPFJbe7fsDx3CXhMSNd5W6htfwWL3kpKsRq9LweN20docoKbSTjDgptbxr7CExw83+H+rd+8hnTz1rlxqsxMVvV08t20bL8TEo1Kn4Q60UFyQS06GhlKzAVtRFr5qM64KAz2hPZweGWLkzAhDp0YYPjPK+x++x/H+Y/wDsAgaJjEJjE4AAAAASUVORK5CYII=","aspectRatio":1.7605633802816902,"src":"/static/ffd913ea2c0d67b777d7e1310e8ad91e/46604/gb.png","srcSet":"/static/ffd913ea2c0d67b777d7e1310e8ad91e/62d80/gb.png 125w,\n/static/ffd913ea2c0d67b777d7e1310e8ad91e/e1953/gb.png 250w,\n/static/ffd913ea2c0d67b777d7e1310e8ad91e/46604/gb.png 500w,\n/static/ffd913ea2c0d67b777d7e1310e8ad91e/d8815/gb.png 750w,\n/static/ffd913ea2c0d67b777d7e1310e8ad91e/38fcf/gb.png 846w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["임베디드","아두이노","ESP8266"]},"rawMarkdownBody":"\n# 프로젝트명\n\n### 스마트팜 Great Brain\n\n---\n\n### 제품 설명\n\n**나만의 작은 스마트팜**\n\n\"하드웨어와 소프트웨어로 완벽한 식물을 기른다.”\n\n- **토양 수분 센서를 이용해 토양 수분 확인**\n\n토양수분 센서를 흙에 꽃아 흙의 수분양을 파악\n\n- **자동으로 펌프를 이용해서 수분공급**\n\n토양수분 센서로 인식된 값이 일정 수준보다 낮을 때 자동으로 수분을 공급\n\n- **식물 관리를 위한 앱**\n\n현재 수분/ 습도/ 광량을 앱에서 모니터링 및 수동 제어 가능\n\n---\n\n> 💡 자세한 것은 GitHub & YouTube에서 확인할 수 있습니다.\n\n**유튜브**\n\n> [https://youtu.be/KRRq1sTHHP8](https://youtu.be/KRRq1sTHHP8)\n\n**깃허브**\n\n> [https://github.com/MinSeok0123/ESP8266_SmartPlant](https://github.com/MinSeok0123/ESP8266_SmartPlant)\n\n### 나의 역할\n\n- 하드웨어를 맡아 전체적인 하드웨어 개발\n- 소개 영상편집 및 자료정리\n- 123design를 이용해 하드웨어 외형을 설계하고 3D프린터로 제작\n- 하드웨어 사용을 위한 회로를 설계하고 연결\n- 하드웨어에 토양수분센서를 통해 값을 받아 불필요한 값을 처리해서 서버로 전송\n- ESP를 통해 WIFI를 연결하고 Node.Js를 통해 값을 전달\n- 토양수분센서를 통해 값이 낮으면 서버에 값을 넘겨서 펌프작동\n- 습도/온도 값을 ESP8266을 통해 받아 서버에 값을 보내기\n\n---\n\n## 느낀점\n\n- 1년 프로젝트이기에 힘들었던 점도 있고 많은 것을 했기에 좋은 경험인 것 같다.\n- 팀원들과의 갈등과 협업을 해야 하는 일이 생기면서 팀원들과 소통의 중요성을 알게 되었다.\n- 프로젝트를 하기 전에 설문 조사, 자료 조사를 하면서 사용자는 내 생각과는 다른 문제점을 가지고 있을 수도 있다는 것을 알게 되었다.\n- 123design를 통해 3D 모델링을 설계하고 3D 프린터를 통해 제작하는 것에 대해 알게 되었다.\n- 회로를 설계하는 것에 저항 등 많은 것을 생각해야 한다는 것을 알게 되었다.\n- ESP를 통해 WIFI를 연결하고 Node.Js로 서버 통신을 하는 것을 알게 되었다.\n- 1년 동안 준비한 프로젝트인데 상을 타게 되어서 뿌듯했고 더 열심히 할 것이라고 다짐하였다.\n"},{"id":"43ff11f6-1f8d-5d67-affe-7828935f8dd6","excerpt":"Java Collection Framework Java Collection Framework는 자바에서 제공하는 데이터 구조와 관련된 클래스와 인터페이스의 집합이다. 이것은 다양한 자료구조의 구현을 제공하고, 컬렉션 클래스를 사용하여 데이터를 저장, 검색, 정렬, 삭제 등 다양한 연산을 수행할 수 있다. 여기서는 컬렉션 프레임워크의 중요한 두 가지 클래스인 ArrayList와 HashMap에 대해 알아보겠다. List : List…","fields":{"slug":"/Java Collection Framework에 대해 알아보자/"},"frontmatter":{"title":"Java Collection Framework에 대해 알아보자","date":"2023.03.29","thumbnail":{"publicURL":"/static/3aa370900eed0712859f2bc47d4b807e/java.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABRNAAAUTQGUyo0vAAAD7UlEQVR42m2Uf0zUZRzHv4AIwnnoFn9gJCBRMwe6RnPSH5G1XLV0s621tdyqlZstwx8zMKSLA+8nUpuAljgCEfQPGJAiv44fJ/cDvBAMRzniOHHCzBYSAncHr/b93p3ceXy3Z8+zZ8/39bzfn+fz+QhrtWaChwmZOGtMxOgshBSaiFC0kVliYJu+BeFEO0llgySU/MZada/nrPe8EATTLMPkIiy/m3fL2rGM2GFhlnpDL9omMwePKziclcXuHxoIKbhOjG4loMYkzTKNiXV6C6sKejhyyQi4we1k6sHfDA0NsXvXm6Q+n8DRXAXJJ68SqfG6CgD6wdbrzAiFFl4r+hUWF5h3Ork9MkJXRxu7dmayZ+/7HNCXk6BqJVxlQu79T/w/AChuxmjNrFKZ2aJrwXb7DuI3t+BkYtzOR1/nkHqkhM2aFiKUXUSozQGwAIVi3ORaE2u0VhLUbfzluCfBXO5FlpaWpPXE/SlSlA0IKqsUM7nXpr/DAIVi3ARFN3n1ZgkwO+/E7XJJa6fLLc0Fta0I2VdYV9QXoMzHEfxTRa6zsjq/k+rOG4BHVV1dHaPj4/i+uw4HidlVROr6kIsg3wgCSpsmorRWPlSWUX6mBPu4g+qaGgwVFTiMRo/SuVlSvqkgSgRKlpdfeBnovUVM4lBFByrdWQy1VfxUfp5HMzMsjo7itI8zP/eY4svNhB2uRcjvIUpr8T6mOVChzBsHESgoe3hdcRGzbZih4WHcbjcLi4vYHQ7+GBmhu3+QZssgxW2DPFPQSvQT6FMKxedfrTKxo+gq75SKgW9E29jLw8l72O9O8O/srGT5wdQkN239jN4aICWnkgitXyz9gR51Rg6VN8HSDB03hhiw3WTJPobr4T8wNsaAoZPLdfXYLCb2q88gHG0k5lS/pM5n+4llSbbOijy/jc/OXaOqrgnb4C1+v/8f06N2+PMOjycnOZaTQ0ZGBgfz9ey70EtEYc9Keei9wQsVvutAOFCFss7ItGuJR/Mupqan+fH0abampbEmWkbWF5/Q1TdAWG4zcr012PJyy+pl/al+wlVmXsh8j48/2Mtbb+xk65aXSNqUTGJiEgnPxfPiK6+SprhERKFRin9Qpcj8klRMh82qK6SmbycsRECeso241O0kb4glbsOzbNoYT+a+rwg70YJc76kYWXCl+CxbkBcY+Pl8BZ3NTZQXq9mjPEfY56XE7Xib1JfTOZl3nC+1ZwnNbSbGZzeolv1kR6uuk55XyaHSWj7V/8LG7CqidX2Efm9gf1EFNReriT9WKTUSX4OQrQSU+RV6uKYP4UQbwrfXiFR7Oku0zkpsYTuxeQ3S3tONQQT+D0iADDNOE6BCAAAAAElFTkSuQmCC","aspectRatio":1,"src":"/static/3aa370900eed0712859f2bc47d4b807e/46604/java.png","srcSet":"/static/3aa370900eed0712859f2bc47d4b807e/62d80/java.png 125w,\n/static/3aa370900eed0712859f2bc47d4b807e/e1953/java.png 250w,\n/static/3aa370900eed0712859f2bc47d4b807e/46604/java.png 500w,\n/static/3aa370900eed0712859f2bc47d4b807e/d8815/java.png 750w,\n/static/3aa370900eed0712859f2bc47d4b807e/31987/java.png 1000w,\n/static/3aa370900eed0712859f2bc47d4b807e/22f13/java.png 2048w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["Java"]},"rawMarkdownBody":"\n# Java Collection Framework\nJava Collection Framework는 자바에서 제공하는 데이터 구조와 관련된 클래스와 인터페이스의 집합이다. 이것은 다양한 자료구조의 구현을 제공하고, 컬렉션 클래스를 사용하여 데이터를 저장, 검색, 정렬, 삭제 등 다양한 연산을 수행할 수 있다. 여기서는 컬렉션 프레임워크의 중요한 두 가지 클래스인 ArrayList와 HashMap에 대해 알아보겠다.\n\n**List** : List 인터페이스는 순서가 있는 컬렉션을 나타내며, 데이터를 중복해서 저장할 수 있습니다. ArrayList, LinkedList, Vector 등이 이에 해당합니다.\n\n**Set** : Set 인터페이스는 순서가 없는 컬렉션을 나타내며, 데이터를 중복해서 저장할 수 없습니다. HashSet, TreeSet 등이 이에 해당합니다.\n\n**Map** : Map 인터페이스는 키-값 쌍으로 이루어진 데이터를 저장합니다. HashMap, TreeMap 등이 이에 해당합니다.\n\n\n# 1. 메모리 구조와 함께 파악하기\n\nArrayList와 HashMap은 모두 컬렉션 클래스이지만, 메모리 구조는 다르다.\n\n## ArrayList\nArrayList는 내부적으로 배열을 사용하여 요소를 저장한다. 요소가 추가될 때마다 배열의 크기가 자동으로 증가하며, 요소가 제거될 때마다 배열의 크기가 자동으로 감소한다. 이러한 메모리 구조는 다음과 같다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/16e13dc3-0295-4be9-8e41-23b9331bc115/image.png)\n\n\n## HashMap\nHashMap은 내부적으로 해시 테이블을 사용하여 요소를 저장한다. 해시 테이블은 해시 함수를 사용하여 각 요소를 키-값 쌍으로 매핑하고, 각 키에 대한 값을 해시 테이블 내의 해당 위치에 저장한다. 이러한 메모리 구조는 다음과 같다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/6d4ce393-be97-4756-b243-257999d1fd85/image.png)\n\n\n# 2. Code (Java)\n\n## ArrayList\n```\nimport java.util.ArrayList;\n\npublic class ArrayListExample {\n\n    public static void main(String[] args) {\n        // ArrayList 생성\n        ArrayList<String> names = new ArrayList<>();\n\n        // 요소 추가\n        names.add(\"Mcdonald\");\n        names.add(\"BugerKing\");\n        names.add(\"LotteRia\");\n\n        // 요소 접근\n        System.out.println(names.get(0)); // 출력: Mcdonald\n\n        // 요소 수정\n        names.set(1, \"Shack Shack\");\n\n        // 요소 제거\n        names.remove(2);\n\n        // 전체 출력\n        for (String name : names) {\n            System.out.println(name);\n        }\n    }\n\n}\n\n```\n\n\n## HashMapp\n```\nimport java.util.HashMap;\n\npublic class HashMapExample {\n\n    public static void main(String[] args) {\n        // HashMap 생성\n        HashMap<String, Integer> ages = new HashMap<>();\n\n        // 요소 추가\n        ages.put(\"Mcdonald\", 82);\n        ages.put(\"BugerKing\", 69);\n        ages.put(\"LotteRia\", 43);\n\n        // 요소 접근\n        System.out.println(ages.get(\"BugerKing\")); // 출력: 69\n\n        // 요소 수정\n        ages.replace(\"LotteRia\", 44);\n\n        // 요소 제거\n        ages.remove(\"Mcdonald\");\n\n        // 전체 출력\n        for (String name : ages.keySet()) {\n            System.out.println(name + \": \" + ages.get(name));\n        }\n    }\n\n}\n\n```\n"},{"id":"813d4b3a-2e13-5f1c-994c-6428fb76781b","excerpt":"recoil 이란 무엇인가? Recoil은 페이스북에서 만든 React 상태 관리 라이브러리입니다. React는 기본적으로 단방향 데이터 흐름을 따르기 때문에 복잡한 상태 관리를 위해서는 상태를 끌어올리거나 Redux와 같은 상태 관리 라이브러리를 사용해야 했습니다. 하지만 Recoil은 기존 React 컴포넌트 내에서 상태를 관리할 수 있도록 해줍니다. Recoil의 특징 Recoil은 다음과 같은 특징을 가지고 있습니다.…","fields":{"slug":"/recoil을 한번 알아보자/"},"frontmatter":{"title":"recoil을 한번 알아보자","date":"2023.04.21","thumbnail":{"publicURL":"/static/99c93761c35cacaf0b3380b23024878f/recoil.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAIAAABSJhvpAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZUlEQVR42tWTSU/CQBiG+auePPojvBj1QESNNihBWSwgCFVkkc0AbkSJYAIJdAUU6EKLC3WmHYNoVQ6acDCaTL5kJu+T95tvMdGiNvEx/QGYEuDkMCPpP6opAX72+IBrHZXkgXElecBI+khqAKysMdJXZ5IH7QFatbmjuauOiiherXfVZl8n+edR5GRIi4CWYJkRK817I0cTJUBORiVaXLXhVtce20PecMbuDRPJC8zh9xyknYH4biTrCh55w5n1bX8sX2o9oFEuQ7jZR4VKa86MrW35au3B4vLmktU9u7Bi2XDPW6zZIokTKXw/HT8pT03PxPLXrzB4gxsKKta7Zszhj+ZIHhDJ83ShGkqcuYLx48uq3XcYiOZ2QgmcSDkDsdMbtqG8Ow//3AU8QJjDE8kW754Q29M4WW8oGi1CRoKMBDgFcrLO9rTbx2GkhPFqQ5IHRm2Nloy9GJpvJgz+7oT9q616AaeylZZ46NGLAAAAAElFTkSuQmCC","aspectRatio":1.179245283018868,"src":"/static/99c93761c35cacaf0b3380b23024878f/46604/recoil.png","srcSet":"/static/99c93761c35cacaf0b3380b23024878f/62d80/recoil.png 125w,\n/static/99c93761c35cacaf0b3380b23024878f/e1953/recoil.png 250w,\n/static/99c93761c35cacaf0b3380b23024878f/46604/recoil.png 500w,\n/static/99c93761c35cacaf0b3380b23024878f/aa591/recoil.png 672w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["Web","Frontend","React"]},"rawMarkdownBody":"\n\n# recoil 이란 무엇인가?\n\nRecoil은 페이스북에서 만든 React 상태 관리 라이브러리입니다. React는 기본적으로 단방향 데이터 흐름을 따르기 때문에 복잡한 상태 관리를 위해서는 상태를 끌어올리거나 Redux와 같은 상태 관리 라이브러리를 사용해야 했습니다. 하지만 Recoil은 기존 React 컴포넌트 내에서 상태를 관리할 수 있도록 해줍니다.\n\n# Recoil의 특징\n\nRecoil은 다음과 같은 특징을 가지고 있습니다.\n\n### 1. 기존 컴포넌트에서 상태 관리\n\nRecoil은 React의 Context API와 유사한 방식으로 상태를 관리합니다. 컴포넌트 내에서 상태를 정의하고 사용할 수 있으며, 다른 컴포넌트에서도 해당 상태를 사용할 수 있습니다. 이렇게 함으로써 Redux와 같은 별도의 상태 관리 라이브러리를 사용하지 않아도 되는 장점이 있습니다.\n\n### 2. 비동기 처리\n\nRecoil은 비동기 상태 관리도 지원합니다. Promise나 async/await를 사용하여 비동기 처리를 할 수 있으며, 상태 변화를 감지하여 자동으로 컴포넌트를 업데이트합니다.\n\n### 3. DevTools 제공\n\nRecoil은 개발자 도구(DevTools)를 제공합니다. DevTools를 사용하면 상태 변화를 쉽게 추적하고 디버깅할 수 있습니다.\n\n## Recoil 사용 예시\n\nRecoil을 사용하면 다음과 같이 컴포넌트 내에서 상태를 정의하고 사용할 수 있습니다.\n\n```\nimport { atom, useRecoilState } from 'recoil';\n\n// 상태 정의\nconst counterState = atom({\n  key: 'counterState',\n  default: 0,\n});\n\n// 컴포넌트에서 상태 사용\nfunction Counter() {\n  const [count, setCount] = useRecoilState(counterState);\n\n  function handleClick() {\n    setCount(count + 1);\n  }\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={handleClick}>Increment</button>\n    </div>\n  );\n}\n\n```\n\n위 코드에서 atom 함수를 사용하여 상태를 정의하고, useRecoilState 훅을 사용하여 해당 상태를 컴포넌트 내에서 사용합니다. handleClick 함수에서 setCount 함수를 사용하여 상태를 업데이트합니다.\n\n## 결론\n\nRecoil은 React 상태 관리를 쉽게 해주는 라이브러리로, 기존의 Redux와 같은 상태 관리 라이브러리보다 더 직관적이고 간단하게 상태를 관리할 수 있습니다. Recoil을 사용하면 기존의 React 컴포넌트 내에서 상태를 관리할 수 있어서 별도의 상태 관리 라이브러리를 사용하지 않아도 됩니다. 또한 비동기 상태 관리도 지원하며 개발자 도구(DevTools)를 제공하여 상태 변화를 쉽게 추적하고 디버깅할 수 있습니다.\n\n"},{"id":"43e5fe65-95f9-5606-bd24-45463e65e210","excerpt":"1. 리액트 프로퍼티 (props)를 사용하는 이유 리액트는 UI 라이브러리로서, 컴포넌트를 사용하여 UI를 구성한다. 이 때, 컴포넌트 간의 데이터 전달을 위해 프로퍼티(Props)를 사용해야한다. 2. 프로퍼티의 특징은 무엇인가? 프로퍼티는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터라서. 이 데이터는 자식 컴포넌트에서 읽기 전용으로 사용된다. 즉, 자식 컴포넌트에서는 해당 데이터를 직접 수정할 수 없다.…","fields":{"slug":"/리액트props/"},"frontmatter":{"title":"리액트 props 사용하는 이유","date":"2023.04.11","thumbnail":{"publicURL":"/static/08313e5f3a1c429de915af9fa1ccfeaa/1.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABRNAAAUTQGUyo0vAAADsklEQVR42nWUW0ybZRjHe6vJvJkmExF16pU7aLIL40AHjUBQyCaHcehKC6wHhEkmQWHTRbMME8WbzSAGCURIo5sOh9mAZTjc5sA5xrp2HFrOlB4otI2j7Tj0Z75vFErp3uTL8+XNm9/z/J+TRG2DTZ81gMoGKmsArR0UNpAPe/jMaOFo/wTZo14q3FA+D6qZZfGtevW9JBwmXAatxgHyqUW+7B/FYLHh97j44/rf6PRDfHqymiOlJVRe6RUdaoQgNgFDYFobKKaX+OGuCRYf8nDhARarFb1eT4o0gVeitlFWWYWmb5zDjlVVocBHkT261FoD5Dvhk94B8C3g9fu5ZzDSdbmT+NhYUlJTOdbQgtZgpdC+DhM4kvC8CbbQAUf6JzGMjiMc/+IiI8PDKCsqkTX/Tkn/JMoJP4fDYBElq2ah2Gjnxj+38DhncXs8BI9pbAzVzUEK50Fj2wzbEGEwb7LpZZoMI8yMmLjVdwefzyfClgMB0Z7pvErW4DzFDjbBNkkWqpo/5qXDMATLSyKgtbWVkfHxtSgHBwaQXbqJeg7UMysi7LHAoOTypp+pO3OaiakpWnQ6uhobGe/uFoGuWQfytr/WgbYIRQl6EZo4b3SB+iYdFxsbqKv/EZfbzZLJBHY7Pq+X2rZL7L82gNyygsoRUszwCINAIYdVl3vRD5oYNpvXpJ49f564uDi2xrxITeNPdNrcFBgd69DwCMV2sUHFbTMn+kzk3ndyvPks31SfIidPRkx0NFFRUaKt/76WoTt9KC7eQBWSyw1AoQ3yZwJ83d4Nnjmqv6vliS1PsWWvlCeVZUS/voc3du/ml3O/cu3PLo41NHPAMEuxczVloZKDi0AtzO59JzU9etTlFWx75mmiS6rYerKO5/Ylsf2FGDKzssjLy+Pz07V8a5ykYGppw9hKwreLAM0x/8fBu1b25Cp49uVXeT4+me2v7WTXjh0kJibxblIyJ8qPcqWnF9mQS2y3iDkU/2dW0ArT4oS0Ii3xsXtJeOtNkqUJfJCRSXZuLukZGaQdyqeos4dCy/LjJyVYrQ8dkH57CmmBhvREKfty5byvLCI7LZWDmRkoUlNQHv+CnCGX6DxyY69KF1ZRqdnNoZYLSK5O89FXNZQ1n+O9C9dJK/2Yd3Lk7DpVy4HG31AMzqGZZcO0SCIuV8sSqe3/8lL7Pd7WdSLr6BUnSDbyAKWuDamug9guIyUhsIjANagdtE7Qmt0UDLvW1pQgr8jkRtk3QfFqd6hD5ArA/wFMH9PDxsg+KQAAAABJRU5ErkJggg==","aspectRatio":1,"src":"/static/08313e5f3a1c429de915af9fa1ccfeaa/46604/1.png","srcSet":"/static/08313e5f3a1c429de915af9fa1ccfeaa/62d80/1.png 125w,\n/static/08313e5f3a1c429de915af9fa1ccfeaa/e1953/1.png 250w,\n/static/08313e5f3a1c429de915af9fa1ccfeaa/46604/1.png 500w,\n/static/08313e5f3a1c429de915af9fa1ccfeaa/d8815/1.png 750w,\n/static/08313e5f3a1c429de915af9fa1ccfeaa/31987/1.png 1000w,\n/static/08313e5f3a1c429de915af9fa1ccfeaa/22f13/1.png 2048w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["Web","React"]},"rawMarkdownBody":"\n# 1. 리액트 프로퍼티 (props)를 사용하는 이유\n\n리액트는 UI 라이브러리로서, 컴포넌트를 사용하여 UI를 구성한다. 이 때, 컴포넌트 간의 데이터 전달을 위해 프로퍼티(Props)를 사용해야한다.\n\n# 2. 프로퍼티의 특징은 무엇인가?\n\n프로퍼티는 부모 컴포넌트에서 자식 컴포넌트로 전달되는 데이터라서. 이 데이터는 자식 컴포넌트에서 읽기 전용으로 사용된다. 즉, 자식 컴포넌트에서는 해당 데이터를 직접 수정할 수 없다.\n\n# 3. 프로퍼티 전달방법\n\n프로퍼티는 부모 컴포넌트에서 자식 컴포넌트로 전달될 때 객체 형태로 전달된다. 자식 컴포넌트에서는 이 객체를 받아서 사용할 수 있다. 프로퍼티는 함수형 컴포넌트에서는 함수의 매개변수로, 클래스형 컴포넌트에서는 this.props로 접근할 수 있다.\n\n> 아래는 프로퍼티를 이용하여 부모 컴포넌트에서 자식 컴포넌트로 이름과 나이를 전달하는 코드이다.\n\n_부모 컴포넌트_\n\n```\nimport React from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n  return (\n    <div>\n      <ChildComponent name=\"John\" age={30} />\n    </div>\n  );\n}\n\nexport default ParentComponent;\n\n```\n\n_자식 컴포넌트_\n\n```\nimport React from 'react';\n\nfunction ChildComponent(props) {\n  const { name, age } = props;\n  return (\n    <div>\n      <p>Name: {name}</p>\n      <p>Age: {age}</p>\n    </div>\n  );\n}\n\nexport default ChildComponent;\n\n```\n\n# 4. 자식 컴포넌트에서 부모 컴포넌트의 상태 변경을 위한 콜백 함수 전달 방법\n\n프로퍼티를 사용하여 자식 컴포넌트에서 부모 컴포넌트의 상태를 변경하고 싶다면, 콜백 함수를 프로퍼티로 전달하여 사용할 수 있다. 이 콜백 함수는 자식 컴포넌트에서 실행되어 부모 컴포넌트의 상태를 변경할 수 있다.\n\n> 부모 컴포넌트에서 자식 컴포넌트에서 실행될 콜백 함수를 만들어 전달하는 코드이다.\n\n_부모 컴포넌트_\n\n```\nimport React, { useState } from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n  const [name, setName] = useState('John');\n\n  const handleNameChange = (newName) => {\n    setName(newName);\n  };\n\n  return (\n    <div>\n      <p>Name: {name}</p>\n      <ChildComponent onNameChange={handleNameChange} />\n    </div>\n  );\n}\n\nexport default ParentComponent;\n\n```\n\n_자식 컴포넌트_\n\n```\nimport React, { useState } from 'react';\n\nfunction ChildComponent(props) {\n  const [inputName, setInputName] = useState('');\n\n  const handleInputChange = (event) => {\n    setInputName(event.target.value);\n  };\n\n  const handleButtonClick = () => {\n    props.onNameChange(inputName);\n    setInputName('');\n  };\n\n  return (\n    <div>\n      <input type=\"text\" value={inputName} onChange={handleInputChange} />\n      <button onClick={handleButtonClick}>Change Name</button>\n    </div>\n  );\n}\n\nexport default ChildComponent;\n\n```\n\n# 5. 프로퍼티를 사용한 컴포넌트 간 데이터 전달의 장점은 무엇인가?\n\n프로퍼티를 사용하면 데이터를 쉽게 공유하고 재사용할 수 있어 코드의 재사용성이 높아지며, 단방향 데이터 흐름으로 인해 데이터 추적이 쉬워지고 디버깅이 쉬워지며, 컴포넌트 간의 의존성이 낮아져 코드 수정이나 유지 보수가 쉬워지며, 가상 DOM을 사용하여 성능을 개선할 수 있다.\n"},{"id":"d3342002-e371-5bb7-ab44-e71983320c31","excerpt":"시뮬레이션과 완전탐색 개념 시뮬레이션과 완전탐색은 CS에서 중요한 개념으로, 다양한 문제를 해결하기 위해 사용된다.\n시뮬레이션과 완전탐색에 대해 알아보고, 각각의 개념을 어떻게 활용하는지 알아보자. 1. 시뮬레이션(Simulation…","fields":{"slug":"/시뮬레이션과 완전탐색/"},"frontmatter":{"title":"시뮬레이션과 완전탐색","date":"2023.05.12","thumbnail":{"publicURL":"/static/cc3ebf5b6a941408a03a690e03ec3a5f/simulation.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEz0lEQVR42gHEBDv7AA8qMRArMxEsNBEtNBAuNRAvNxExOREzOxE2PhI5QhA7RQ89RxE+Rw08RBQ/SBI6RRM8RRAyOg0rNAwnMAARLTURLTURLzYRMjkSNj0SOUISPkYTQUoTRE4QSlMVWF4mYWYUV101XmcgU14WWmBKZW8MPkoQND0OLDUAETI5ETU8EjlCEz9HE0VNFEpRFExVFk9WFFFXEVpfdYKBfYmIZmt6STlTOV9pW29/QUBbE1djD0ZSDjI8ABM8RBRBShRIUBVNVBZQVxZSWBZVWxVWWw1WWmmIg7mCfqd2fUwvTTIfNFlAXj0lRCwoPFBwhz5wgyBSXgAWSlIWT1YXU1oXVlwYWF0YWl8WW18lZ2gXZWa0r5fAfXVkQmIwHzpCLkw1JD8sGipDMFE7MFVZWnomWGcAGVhdGVtfGl1hGmBiG2FkHGRmE2FiPX56uL6nxZOBgUVMXC01Vy0wTCo0KxQYGREmJBs0EAwZRh0XJmVjAB1kZh1mZx1qaR1sah1sah1sahtsaid0bcbEqNGGeIYrE4A0GX4yEFwjBC0OBEgaAEoWAWEiAGMmCS5BWAAjd3Ile3QlfHUjenMhd3Egc24dcGwrfXTBs4rUijJfUgtQHCGTcBRZgRsgDAlaIQRpXFY2L0EaEBw1KD8AI6eIGbWKHq2HJ5iAJ4h7I4B2I3pxHH52jItp5bIbZHoTNgkOyIQYb2QNFgIOIxQgRjtCLCpEFRInTj1JAAfOjwrYlBXUkh/BjCughiqPfySFeR+EeKKvlbRiPk8ZDnsyKqpFO14kKH89QXQyOCoODSkWJTcvPa9cPwBhz50z0pMT0Y0Sy4gktYgxm4UqkX4eh3k5l4OpqIusXEjYk271xZHqq4a6YFJdNTYvITk1LTrEhE+vTy0A/+nb6OHJvdu3i9GfOsGKL6qHLpeBKZB9H417Mp6EfKSAk35cypBmw2hVZTIyCxgqGBk2FyI9qnlElEUnAPXhzfzm0v3dxP/PrJ/Ikh2/ijKdgiSbgyKfhBqkhR+/jl6zdXAvImIJCUkpKhEZMBIWLwARNH9ZOXo2IQD01bz37NX37dPww5XjsX83yIwluodCsX82uIFYsXVunHFUZFpVOjI1FhkYJjEMCx0NEioEGD0yIzNgKB4Ar5iH/+TC9uTC6bmK4pJyl55ymIlWxFw+u2A+4Gc/rGNMKklahFdFcD8yTllOcldNGh8+AQ8qMB4qSyEaACpAS9KQbvCzhOOfe9SOdNV8Yp9DP3gwN6tCOb9YRLZTONNkP65ROVNAS1tSXD09WBUhPwIMHz8gHzcYFQAWVWStclHccUOJUEiwb1zYi26aVVVlITRjJiZPICZPNTx6W1B2QkAqKUkQJU0YKE8PGDAHDBo+IiEsExIAWU1Mq2dNxV9AWjQ5XDM2slE+/61c1ppieT1DgUpMqGNdtHtqm3NnUkFMIyI4HSM9DxszDRYpLBkaIxETAEIxOlY1N3E7OFYxMlQsL6ZJNPq2TeWbUJZJRGlCQkw4PisoOhwkPzAtPjcwPjMuPywuRCE0TBwwRR8lMQAvNEMJKTsgLjw5ND5CMThAKS1hLCtjLy8mHisSHjMTITsfKEAkJzoiITIcGyoUFCIRFCIdMEMkPFEmP1Z1pYey/tyskAAAAABJRU5ErkJggg==","aspectRatio":1,"src":"/static/cc3ebf5b6a941408a03a690e03ec3a5f/46604/simulation.png","srcSet":"/static/cc3ebf5b6a941408a03a690e03ec3a5f/62d80/simulation.png 125w,\n/static/cc3ebf5b6a941408a03a690e03ec3a5f/e1953/simulation.png 250w,\n/static/cc3ebf5b6a941408a03a690e03ec3a5f/46604/simulation.png 500w,\n/static/cc3ebf5b6a941408a03a690e03ec3a5f/bc59e/simulation.png 512w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","Python"]},"rawMarkdownBody":"\n## 시뮬레이션과 완전탐색 개념\n\n시뮬레이션과 완전탐색은 CS에서 중요한 개념으로, 다양한 문제를 해결하기 위해 사용된다.\n시뮬레이션과 완전탐색에 대해 알아보고, 각각의 개념을 어떻게 활용하는지 알아보자.\n\n### 1. 시뮬레이션(Simulation)\n\n머릿 속에 있는 알고리즘을 소스코드로 바꾸는 과정이다.\n알고리즘을 잘 세우더라도 알고리즘이 실제로 동작하지 않기 때문에 이러한 구현은 반드시 필요한 과정어떠한 알고리즘의 문제를 풀더라도 소스코드로 구현해야 하기 때문에 구현을 구분하지는 않지만, 알고리즘 과정에서 구현이 필요한 문제는 대체적으로 구현에 초점을 둔 어려운 문제가 많이 존재한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/e55ed6bb-5bdd-4a6d-82db-265db5ca1cc5/image.png)\n\n### 2. 완전탐색(Exhaustive Search)\n\n완전탐색은 가능한 모든 경우의 수를 나열하고, 그 중에서 문제의 조건을 만족하는 해결책을 찾는 방법이다. 모든 가능한 경우를 일일이 탐색하기 때문에 정확한 해결책을 찾을 수 있지만, 경우의 수가 많을 경우에는 시간과 리소스가 많이 소요될 수 있다. 따라서 완전탐색은 경우의 수가 비교적 작을 때에 유용하게 활용된다.\n\n## 문제 - 상하좌우\n\n> 여행가 A는 NxN 크기의 정사각형 공간에 서 있고, 이 공간은 1 x 1 크기의 정사각형으로 나누어져 있다.가장 왼쪽 위 좌표는 (1, 1)이고 가장 오른쪽 아래 좌표는 (N, N)이다.상하좌우로 이동할 수 있으며, 시작 좌표는 (1,1)이다.\n>\n> 계획서대로 이동하면 되는데 L, R, U, D는 각각 왼쪽, 오른쪽, 위, 아래로 한칸씩 이동하라는 뜻이다.\n>\n> 만약 공간을 벗어나는 움직임이 있다면 그 움직임은 무시하고 다음으로 넘어간다.\n>\n> 계획서에는 하나의 줄에 띄어쓰기를 기준으로 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 의미는 다음과 같다\n>\n> - L: 왼쪽으로 한 칸 이동\n> - R: 오른쪽으로 한 칸 이동\n> - U: 위로 한 칸 이동\n> - D: 아래로 한 칸 이동\n\n이때 여행가 A가 N × N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다예를 들어 (1, 1)의 위치에서 L 혹은 U를 만나면 무시된다다음은 N = 5인 지도와 계획이다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/0cda2031-eff7-40d9-83d2-ed69060b26de/image.png)\n\n## 코드\n\n```\nn = int(input())  # 정사각형 공간을 입력받는다.\nx, y = 1, 1  # 시작 좌표는 항상 (1, 1)이므로 1, 1로 x, y 초기화\nplans = input().split() # 이동 계획을 입력받는다.\n\n# 상하좌우(L, R, U, D)에 따른 이동 방향\ndx = [0, 0, -1, 1]\ndy = [-1, 1, 0, 0]\n\nmove_types = ['L', 'R', 'U', 'D']\n\n# 입력받은 이동 계획을 하나씩 조회\nfor plan in plans:\n    for i in range(len(move_types)):\n    \t# move_types와 일치하는 plan이 있다면\n        if plan == move_types[i]:\n        # 이동한 A의 좌표 nx, ny\n            nx = x + dx[i]\n            ny = y + dy[i]\n\n    # N x N 크기의 정사각형을 벗어나면 움직임은 무시되므로\n    if nx < 1 or ny < 1 or nx > n or ny > n:\n        continue\n\n    #  공간안에 있다면 A의 좌표 이동\n    x, y = nx, ny\n\nprint(x, y)\n```\n\n1. 입력으로 정사각형 공간의 크기 N을 받습니다.\n2. A의 초기 위치를 (1, 1)로 설정합니다.\n3. 이동 계획을 입력받습니다.\n4. 상하좌우 이동에 따른 x, y의 변화량을 설정합니다.\n5. 이동 계획을 하나씩 조회하며, 이동 계획과 move_types를 비교하여 일치하는 이동 방향을 찾습니다.\n6. 해당 이동 방향에 따라 A의 좌표를 이동합니다.\n7. 이동한 좌표가 정사각형 공간을 벗어나지 않는지 체크하고, 벗어나면 움직임을 무시합니다.\n8. 모든 이동 계획을 처리한 후 A의 최종 위치를 출력합니다.\n\n### 3. 시뮬레이션과 완전탐색의 활용 예시\n\n시뮬레이션과 완전탐색은 다양한 문제 해결에 활용될 수 있다.\n\n- 게임 개발: 게임에서 특정 상황의 결과를 예측하고 시뮬레이션하여 게임의 균형을 조절하거나 최적화할 수 있다. 완전탐색을 사용하여 게임의 모든 가능한 상태를 탐색하여 최적 전략을 찾을 수도 있다.\n- 경제 모델링: 경제학자들은 경제 시스템을 모델링하여 다양한 정책 결정에 대한 결과를 예측하고 분석한다. 시뮬레이션을 통해 경제 시스템의 동작을 모방하고, 완전탐색을 통해 최적의 정책을 찾을 수 있다.\n- 여행 경로 최적화: 여행 경로 최적화 문제는 주어진 도시들을 방문하는 가장 짧은 경로를 찾는 문제이다. 가능한 모든 경로를 탐색하여 최단 경로를 찾을 수 있다.\n"},{"id":"a99447dc-9148-5a1b-b10a-714d9622f8b3","excerpt":"…","fields":{"slug":"/아두이노 스마트 쓰레기통/"},"frontmatter":{"title":"아두이노 스마트 쓰레기통","date":"2021.10.14","thumbnail":{"publicURL":"/static/6fa610f8862c87b1846b866a818c88df/arduino.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADxUlEQVR42nWUa0ybVRzGT7lsTBbcBITGTMgmEInDLYuyaIwmJuLiZRMv8/LB7IOXBDd0m1MyGAGUtgItbd+26wUKOHBOypA5miIuogtSWMyYNBTYyNgEYkSDGgfEpD+ltdCu3Zv8c5KT9/zO85z/RQijjYgwWFdWmcmG0JoQNVp2NjSTY7AgVBpSPz3JHU2tCMkSfi4CFAKLWYbpzBS0nGBg3AuLCzi+7eOjs04OlJbxXnExBSYLQnecmFsCg6vZjqhvYF+jncX5Gywswi9zfzJy6SK7CwrI27KZQ2XHSNdIASdBMVFhpgZErYEXFC/jUmYw2LSTkc6XONuu59HHd7Gn8Dne0GhJ1ZkQeguy0POrCq0rsHi1RKv0IKetKVxtSYTeteCK47cmwZsf7CZFY0XUSwjJGg4LV2gj1mhGSK08oXuLq11JOFRyLjkSGO9OYrQ7GdwbOG3MQCglZObGVZtRFf6vTqaWqFHl4jYmcqpqE19oduCoyaRPfzu95jW018vYUFmKMLcgDJZw2ArQ/6gW/0+5FYdwWos5/00nU1c8nPu6F2d3Fz8O9jF0rhWX9CIPFT2LMLUEzoSqjKYwuU5C0dZBR0cXwz956Ojs5IzFyvV+N8vfjb+W2HTwIMLUiCz47kbrTZaDtxxvRByrolqlpKvBhlavZ+raNZbGxliYnGRp4W/qHA5EeTVCY4is3TCgqYE1WiMbD3/IY1XV9F8cxuP14vP5+Mfn4+eZGbxeL+7hYfouXEDz3XnW1UeBrmwcbyRJUctTB94lr7QcoVRT53Tx++wsnonLzPw657d8fXqaz109DLjd3P2xKmA9KtBsJ0Gp5uHsbL60WRkaH2d4dJTvp2fQeUaRRjx+4JB3jMSyCkSFAlGrCzRBVMtGm79I1732Ok9XK2k58xVTExMMzP9B88Rl3PPzfuCVsTFy8vMpKDnKq6cciFDbEVleDnsrot6IOFyCzukCfMzOzTE4MEBlZSVZ2dnEx8VR9Mpeevp/QCjqAsmMsBxc9WZizXZiDFbk928jf8d27s3OIjU5mdvWryddno48PY3M7flsrv7EP2kiFQbVGVb7eXnmJW3JISEukbWZ95CalUVG2p2kye8ieWMquwrziK2tRZjstyjs0Fv0Zvaf/Iyj7+9F2p/LM0cKEUVHSLlvKxmZcvY9v40O6UniVdrVpEROm5B+1hiwODpxtpVwovlttioqAkqUagztbUz2qHik/B2EoXm1W6ICw+ahlhilHlGzPJGtgYksWXigqY3cGgNCbUJ2c8n8F/8C3uS4tDT63MUAAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/6fa610f8862c87b1846b866a818c88df/46604/arduino.png","srcSet":"/static/6fa610f8862c87b1846b866a818c88df/62d80/arduino.png 125w,\n/static/6fa610f8862c87b1846b866a818c88df/e1953/arduino.png 250w,\n/static/6fa610f8862c87b1846b866a818c88df/46604/arduino.png 500w,\n/static/6fa610f8862c87b1846b866a818c88df/d8815/arduino.png 750w,\n/static/6fa610f8862c87b1846b866a818c88df/31987/arduino.png 1000w,\n/static/6fa610f8862c87b1846b866a818c88df/f3583/arduino.png 1200w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["아두이노","임베디드"]},"rawMarkdownBody":"\n# 아두이노 스마트 쓰레기통\n\n일상생활에서 가장 많이 사용하는 쓰레기통은 매우 중요한 용도를 가지고 있습니다. 하지만 쓰레기통이 너무 지저분하거나 차있어서 쓰레기를 버리는 것이 불편한 경우가 있습니다. 이러한 문제점을 해결하기 위해 아두이노를 이용한 스마트 쓰레기통을 만들어보았습니다.\n\n### 프로젝트 내용\n\n이 스마트 쓰레기통은 다음과 같은 기능을 가지고 있습니다.\n\n1. 움직임을 감지하는 센서를 이용하여 자동으로 열립니다.\n2. 초음파 센서를 이용하여 쓰레기통 안에 쓰레기가 얼마나 차있는지 감지합니다.\n3. 쓰레기통이 어느 정도 차면 LED와 부저를 이용하여 알립니다.\n\n### 프로젝트 목적\n\n이 스마트 쓰레기통을 만들기 위한 목적은 다음과 같습니다.\n\n1. 양손에 쓰레기를 들고 있을 때 손으로 쓰레기통을 열기 힘든 경우를 해결합니다.\n2. 지저분한 쓰레기통에 손을 닿지 않고 쓰레기를 버릴 수 있습니다.\n3. 쓰레기통이 너무 차서 더 이상 쓰레기를 넣을 수 없는 경우를 방지합니다.\n\n## 차별화 내용\n\n이 스마트 쓰레기통의 차별화된 기능은 쓰레기통이 어느 정도 차면 소리가 나게 한다는 점입니다. 이 기능은 LED와 부저를 이용하여 쓰레기통이 어느 정도 찼는지 알려주므로 쓰레기통이 넘치지 않도록 미리 비울 수 있습니다.\n\n### 기대 효과\n\n이 스마트 쓰레기통의 가장 큰 기대 효과는 손이 쓰레기통에 닿지 않고도 쓰레기를 버릴 수 있다는 것입니다. 이 기능은 특히 현재 코로나19 상황에서 매우 중요한 역할을 합니다. 또한 쓰레기통이 너무 차지 않도록 미리 비워서 쓰레기가 넘치지 않게 할 수 있으므로 환경보호에도 기여할 수 있습니다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/9bdc5820-3c97-4f0a-8b4d-ea0d26a2a834/image.png)\n\n![](https://velog.velcdn.com/images/minseok0123/post/8b53aed2-0742-4bee-b76c-750ded87c62c/image.png)\n![](https://velog.velcdn.com/images/minseok0123/post/662f4ebf-25c9-4cf2-9117-327463f8a669/image.png)\n\n## 느낀점\n\n이번 아두이노 스마트 쓰레기통 프로젝트를 통해 다양한 센서와 모듈을 사용해보고, 센서 데이터를 이용하여 간단한 제어 작업을 구현하는 것에 대해 배울 수 있었습니다. 또한 쓰레기통이라는 일상적인 물건을 IoT 기술을 활용하여 새로운 기능을 추가하고, 더욱 편리하게 사용할 수 있는 것을 경험해볼 수 있어서 재미있었습니다.\n\n이번 프로젝트를 통해 스마트 홈 IoT 시스템 개발에 대한 관심도 생겼습니다. 미래의 스마트 홈 시스템에는 다양한 센서와 기기가 연결되어 사용자의 생활을 더욱 편리하고 안전하게 해줄 것입니다. 앞으로도 이와 관련된 다양한 프로젝트를 경험해보고 더 많은 것을 배워나갈 계획입니다.\n\n### **소스코드**\n\n> [\bGitHub : https://github.com/MinSeok0123/Arduino_Smartbin](https://github.com/MinSeok0123/Arduino_Smartbin)\n"},{"id":"9b1e6592-e940-54e4-b31b-7301ae1998b8","excerpt":"…","fields":{"slug":"/정렬 알고리즘/"},"frontmatter":{"title":"정렬 알고리즘","date":"2023.05.13","thumbnail":{"publicURL":"/static/eb51d20db908fb423189b6c6fe7e937c/sort.jpeg","childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMEAQIF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAID/9oADAMBAAIQAxAAAAGlvfzNc9cE8ZGkQP/EABsQAQACAwEBAAAAAAAAAAAAAAEAEQIDEyEj/9oACAEBAAEFArIXPpDZR1Y53OeM8F2o/wD/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEDAQE/ASkWf//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/ASn/xAAeEAABBAEFAAAAAAAAAAAAAAAAAQIxMpEDESEiUf/aAAgBAQAGPwKm5xpFG4IKnhAvVCG4P//EAB8QAAIBAgcAAAAAAAAAAAAAAAABETGBIUFRYXGR8P/aAAgBAQABPyH3MmWHcbUsAkxuexzTDuQk6uWUSpmRRA//2gAMAwEAAgADAAAAEOjo/wD/xAAYEQEBAAMAAAAAAAAAAAAAAAAAEQFRYf/aAAgBAwEBPxCo25Jh/8QAFxEAAwEAAAAAAAAAAAAAAAAAABARUf/aAAgBAgEBPxCEK1f/xAAfEAEAAgEDBQAAAAAAAAAAAAABABExIUFxUWGhwdH/2gAIAQEAAT8QTulfr9RCBLhTUSrxGXukNaQie4PbLGdWBJuLkvuKM0wotaEQBHGf/9k=","aspectRatio":1,"src":"/static/eb51d20db908fb423189b6c6fe7e937c/0f3a1/sort.jpg","srcSet":"/static/eb51d20db908fb423189b6c6fe7e937c/1ada3/sort.jpg 125w,\n/static/eb51d20db908fb423189b6c6fe7e937c/8f7df/sort.jpg 250w,\n/static/eb51d20db908fb423189b6c6fe7e937c/0f3a1/sort.jpg 500w,\n/static/eb51d20db908fb423189b6c6fe7e937c/f9913/sort.jpg 750w,\n/static/eb51d20db908fb423189b6c6fe7e937c/a7715/sort.jpg 1000w,\n/static/eb51d20db908fb423189b6c6fe7e937c/ec6c5/sort.jpg 1280w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","Python"]},"rawMarkdownBody":"\n- 정렬알고리즘\n\n**정렬 알고리즘은 주어진 데이터 집합을 특정한 기준에 따라 순서대로 정렬하는 알고리즘이다.**\n\n- 어떻게 정렬할 수 있을까?\n\n![](https://velog.velcdn.com/images/minseok0123/post/8395ff78-e9d1-4db0-941f-866e8bb99ece/image.png)\n\n# [선택정렬]\n\n처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복합니다.\n\n이 알고리즘의 핵심 아이디어는 매번 정렬되지 않은 부분에서 최소값을 찾아서 앞으로 이동시키는 것입니다. 이를 통해 배열의 가장 작은 요소가 정렬 과정 중에 제 위치를 찾아가게 되고, 나머지 요소들도 동일한 원리로 정렬됩니다.\n\n### 선택 정렬 동작 예시\n\n`[Step 0]` 처리되지 않은 데이터 중 가장 작은 '0'을 선택해 가장 앞의 '7'과 바꾼다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/f49cf2aa-c493-4eb6-a1d9-a30e55687329/image.png)\n\n`[Step 1]` 처리되지 않은 데이터 중 가장 작은 '1'을 선택해 가장 앞의 '5'와 바꾼다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/76d0da14-0233-48e3-83ce-ac4e3fb44983/image.png)\n\n`[Step 2]` 처리되지 않은 데이터 중 가장 작은 '2'를 선택해 가장 앞의 '9'와 바꾼다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/321dee96-a939-4851-a718-9a2e0d6699de/image.png)\n\n`[Step 3]` 처리되지 않은 데이터 중 가장 작은 '3'을 선택해 가장 앞의 '7'과 바꾼다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/f1c1055f-804b-4347-9611-7d53cd778719/image.png)\n\n이러한 과정을 반복하면 다음과 같이 정렬이 완료된다.\n\n→ 가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/1c31e865-5abc-4aaa-bd0d-f5ae98079c6a/image.png)\n\n선택정렬 소스 코드\n\n```python\narray = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]\n\nfor i in range(len(array)):\n\tmin_index = i\n\tfor j in range(i+1, len(array)):\n\t\t\tif array[min_index] > array[j]:\n\t\t\t\t\tmin_index = j\n\tarray[i], array[min_index] = array[min_index], array[i]\n\nprint(array)\n```\n\n```\n[0 1 2 3 4 5 6 7 8 9]\n```\n\n### 선택 정렬의 시간 복잡도\n\n선택 정렬의 시간 복잡도는 O(n^2)로, 배열의 크기에 비례하여 비효율적입니다.\n그러나 선택 정렬은 구현이 간단하고 이해하기 쉬우며, 정렬해야 할 요소의 수가 상대적으로 작을 때 유용할 수 있습니다.\n\n- 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.\n- 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/5868ecb5-6e5d-4b2b-92bc-f591635d2e36/image.png)\n\n- 이는 (*N^*2+_N_+2)/2로 표현할 수 있는데, 빅오 표현법에 따라서 *O*(*N^*2)이라고 작성한다.\n\n# [삽입정렬]\n\n삽입 정렬의 핵심 아이디어는 정렬된 부분 배열에 새로운 원소를 삽입하는 동안 정렬된 순서를 유지한다는 것입니다. 따라서, 배열이 이미 거의 정렬되어 있는 경우에는 효율적으로 동작하며, 작은 규모의 입력에 대해서도 성능이 좋습니다.\n\n- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.\n- 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작한다.\n\n### 삽입 정렬 동작 예시\n\n`[Step 0]` 첫 번째 데이터 '7'은 그 자체로 정렬이 되어 있다고 판단하고, 두 번째 데이터인 '5'가 어떤 위치로 들어갈지 판단한다. '7'의 왼쪽으로 들어가거나 오른쪽으로 들어가거나 두 경우만 존재한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/a5999124-08d7-4896-8665-ef86ae089268/image.png)\n\n`[Step 1]` 이어서 '9'가 어떤 위치로 들어갈지 판단한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/a992c974-23b7-4896-a7ac-96932f3ae382/image.png)\n\n‘9’는 차례대로 왼쪽에 있는 데이터와 비교해서 왼쪽 데이터보다 더 작다면 위치를 바꿔 주고 그렇지 않다면 그냥 그 자리에 머물러 있도록 한다. ‘9’는 ‘7’보다 더 크기 때문에 현재 위치 그대로 내버려 둔다.\n\n`[Step 2]`  이어서 '0'이 어떤 위치로 들어갈지 판단한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/8f710680-7ecb-4e71-8a9a-80f48a2a848e/image.png)\n\n‘0’은 ‘9’, ‘7’, ‘5’와 비교했을 때 모두 작기 때문에 ‘5’의 왼쪽에 위치한다.\n\n이러한 과정을 반복하면 다음과 같이 정렬이 완성된다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/27af6645-9703-4601-9a34-495178c5ee50/image.png)\n\n### 삽입 정렬 소스코드\n\n```python\narray = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]\n\nfor i in range(1, len(array)):\n\tfor j in range(i, 0, -1):\n\t\t\tif array[j] < array[j-1]:\n\t\t\t\t\tarray[j], array[j-1] = array[j-1], array[j]\n\t\t\telse:\n\t\t\t\t\tbreak\n\nprint(array)\n```\n\n`[실행 결과]`\n\n```\n[0,1,2,3,4,5,6,7,8,9]\n```\n\n### 삽입 정렬의 시간 복잡도\n\n삽입 정렬의 시간 복잡도는 최악의 경우에는 O(n^2)이며, 최선의 경우에는 O(n)입니다. 여기서 n은 배열의 크기를 나타냅니다. 또한, 삽입 정렬은 제자리 정렬(in-place sorting) 알고리즘이므로, 추가적인 메모리 공간을 필요로 하지 않습니다.\n\n- 삽입 정렬의 시간 복잡도는 *O*(*N^*2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용된다.\n- 삽입 정렬은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다.`최선의 경우 O(N)의 시간 복잡도를 가진다.`\n\n# [퀵정렬]\n\n- 기준 데이터를 설정하고 **그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법**이다.\n- 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나이다.\n- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘이다.\n- 가장 기본적인 퀵 정렬은 **첫 번째 데이터를 기준 데이터(pivot)로 설정**한다.\n\n### 퀵 정렬 동작 예시\n\n`[Step 0]` 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '7'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '4'가 선택된다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/bc9e8f91-8faf-48d7-943d-776cc4fbd659/image.png)\n\n`[Step 1]` 현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '9'가 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '2'가 선택된다. 이제 이 두 데이터의 위치를 서로 변경한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/c2e69da9-7aae-4449-9080-0689e133b060/image.png)\n\n`[Step 0]`현재 피벗의 값은 '5'이다. 왼쪽에서부터 '5'보다 큰 데이터를 선택하므로 '6'이 선택되고, 오른쪽에서부터 '5'보다 작은 데이터를 선택하므로 '1'이 선택된다. 단, 이처럼\n\n**위치가 엇갈리는 경우 '피벗'과 작은 데이터의 위치를 서로 변경**한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/22b5ce04-0a67-4326-bf30-883814eb9ed5/image.png)\n\n`[분할완료]`이제 '5'의 왼쪽에 있는 데이터는 모두 5보다 작고, 오른쪽에 있는 데이터는 모두 '5'보다 크다는 특징이 있다. 이렇게 피벗을 기준으로 데이터 묶음을 나누는 작업을 분할(Divide)이라고 한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/442f06f2-b4e2-46d8-8e46-4a367ac4e73f/image.png)\n\n`[왼쪽 데이터 묶음 정렬]`왼쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/c99385af-1acd-43ac-848b-143169bb6e30/image.png)\n\n`[오른쪽 데이터 묶음 정렬]`오른쪽에 있는 데이터에 대해서 마찬가지로 정렬을 수행한다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/1a8fb67f-9623-4443-a2a0-5c8bc19bba9d/image.png)\n\n이러한 과정을 반복하면 전체 데이터에 대해서 정렬이 수행된다.\n\n### 퀵 정렬이 빠른 이유: 직관적인 이해\n\n- 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 *O*(_NlogN_)를 기대할 수 있다.\n- `너비 X 높이 = N X logN = NlogN`\n\n![](https://velog.velcdn.com/images/minseok0123/post/f8e6ee2f-3dba-440c-9957-c8be82eb8297/image.png)\n\n### 퀵 정렬의 시간 복잡도\n\n퀵정렬은 평균적으로 O(n log n)의 시간 복잡도를 가지지만, 최악의 경우에는 O(n^2)의 시간 복잡도를 가질 수 있습니다. 최악의 경우는 피벗이 항상 최솟값 또는 최댓값으로 선택되는 경우에 발생합니다. 이러한 경우를 피하기 위해 피벗을 랜덤하게 선택하거나 중간값을 선택하는 방법 등을 사용할 수 있습니다.\n\n- 퀵 정렬은 평균의 경우 *O*(_NlogN_)의 시간 복잡도를 가진다.\n- 하지만 최악의 경우 *O*(*N*2)의 시간 복잡도를 가진다.\n\n`첫 번째 원소를 피벗으로 삼을 때, 이미 정렬된 배열에 대해서 퀵 정렬을 수행할 경우 최악의 경우이다.`\n\n- 표준 라이브러리를 사용하는 경우, 기본적으로 *O*(_NlogN_)을 보장한다.\n\n```python\narray = [5,7,9,0,3,1,6,2,4,8]\n\ndef quick_sort(array, start, end):\n\tif start >= end:\n\t\treturn\n\tpivot = start\n\tleft = start + 1\n\tright = end\n\twhile(left<=right):\n\t\twhile(left<=end and array[left]<=array[pivot]):\n\t\t\tleft += 1\n\t\twhile(right>start and array[right]>=array[pivot]):\n\t\t\tright -= 1\n\t\tif(left>right):\n\t\t\tarray[right], array[pivot] = array[pivot], array[right]\n\t\telse:\n\t\t\tarray[left], array[right] = array[right], array[left]\n\tquick_sort(array, start, right-1)\n\tquick_sort(array, right+1, end)\n\nquick_sort(array, 0, len(array)-1)\nprint(array)\n```\n\n`[실행 결과]`\n\n```\n[0,1,2,3,4,5,6,7,8,9]\n```\n\n# 문제 - 두 배열의 원소 교체\n\n> 동빈이는 두 개의 배열 A와 B를 가지고 있다. 두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는모두 자연수이다\n>\n> 동빈이는 최대 K 번의 바꿔치기 연산을 수행할 수 있는데, 바꿔치기 연산이란 배열 A에 있는 원소 하나와배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말한다\n>\n> 동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며, 여러분은 동빈이를 도와야한다\n>\n> N, K, 그리고 배열 A와 B의 정보가 주어졌을 때, 최대 K 번의 바꿔치기 연산을 수행하여 만들 수 있는배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하라\n>\n> 예를 들어 N = 5, K = 3이고, 배열 A와 B가 다음과 같다고 해보자\n>\n> - 배열 A = [1, 2, 5, 4, 3]\n> - 배열 B = [5, 5, 6, 6, 5]이 경우, 다음과 같이 세 번의 연산을 수행할 수 있다\n> - 연산 1) 배열 A의 원소 '1'과 배열 B의 원소 '6'을 바꾸기\n> - 연산 2) 배열 A의 원소 '2'와 배열 B의 원소 '6'을 바꾸기\n> - 연산 3) 배열 A의 원소 '3'과 배열 B의 원소 '5'를 바꾸기세 번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성될 것이다\n> - 배열 A = [6, 6, 5, 4, 5]\n> - 배열 B = [3, 5, 1, 2, 5]이때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없다\n\n---\n\n### 입력\n\n- 첫 번째 줄: N, K 가 공백으로 구분되어 입력 (1 <= N <= 100,000, 0 <= K <= N)\n- 두 번째 줄: 배열 A의 원소들이 공백으로 구분되어 입력 (원소 a < 10,000,000인 자연수)\n- 세 번째 줄: 배열 B의 원소들이 공백으로 구분되어 입력 (원소 b < 10,000,000인 자연수)\n\n### 출력\n\n- 최대 K번 바꿔치기 연산을 수행해서 가장 최대의 합을 갖는 A의 모든 원소 값의 합을 출력\n\n**입력 예시**\n\n```\n5 3\n1 2 5 4 3\n5 5 6 6 5\n```\n\n**출력 예시**\n\n```\n26\n```\n\n---\n\n**`코드 구현`**\n\n```python\nn, k = map(int, input().split())\n\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\na.sort()\nb.sort(reverse = True)\n\nfor i in range(k):\n  if a[i] < b[i]:\n    a[i], b[i] = b[i], a[i]\n  else:\n    break\n\nprint(sum(a))\n```\n\n---\n\n**`실행 결과`**\n\n```\n26\n```\n\n---\n"},{"id":"0a474589-ef01-5bd6-8fd2-1bd5bee90474","excerpt":"…","fields":{"slug":"/그리디 알고리즘/"},"frontmatter":{"title":"그리디 알고리즘","date":"2023.05.11","thumbnail":{"publicURL":"/static/cdd912ffc0119bc7769fc61a1db10078/greedy.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACr0lEQVR42hXLfVvhAAAA8H2HOwldRRNaaAldh5llMmYbZl7z2prUTaVoWirphbhydaq7D3tPz/P79wewsXgQQymCYMgwRRDxaCzFcQxFMmQ4TkW4OMvF2RTHCYXscf1QkqTb29vBw91j/2E46AMUQQRQjw0CzaAKsZvLxYLUbJ1LrY50VuN5uX12cS6fNhryaeOue1nNsU2x1r/tjoYP4/EIMM5Pm/UzZlDlMGkQmynFhE4OqhenR8OH3n23++/j/X3yOh4NJq/Pz8P+z2L6IE2L24lPxSRgBRXWBRVmM6Cw7vvStNdukuqCfCIOe1f3nfaof3d/fdHrSL2O1GkeP/bOb5r1s+q2LOSezvcBt2U6htoS+WxJFMntTEYQ9lutal08bZ/JsnzVvbm+vnkdvz0/jiYvk5fR+O/Ln49fg0Fj9713AmCrasZjSBIIRRARzFNI0PVSSuDISpIRs0y7Vmjs5KRa+bJxcNUUj7O0nKfvS+QTT/7eowAfrPHBGhox5aO+lpCql2OVBJ4OuqtcaD8V4hNEMYLtUchO2M2TnqMo2k6il2n/s0i9XVWAFf1XJzTlhKZskBI2zMGLWotWvaL/ZjNpHatWtxdxexEURXEcJ7bwMLFFEUQ0QrI0lY4xwA9o1m/TO5bmncsgbJjbsOjRVZNuRglqFKBGgSGuUACnQp/HYTU74eVVC2SFjFbIuLZiBpyQFtQolhbUoEahm1HOqxWz01/XlvWYdyPo9yXjjFAp13j+uH7IsTGWppJswufasFuWYcgIOEw6UKPUqr64rSBuh2jck0slKvm8UCnvlks1nv+0U9qrFHNcNBoOhP2Yyw7DkNFsWgQym3bWC6exNc67xnptDLaejmxmKH+WDuYYIhfxp8MYF/RwARe3uZ4NuPIEUqLwIr2VCvn+AyQr7HErLkBDAAAAAElFTkSuQmCC","aspectRatio":1.6025641025641026,"src":"/static/cdd912ffc0119bc7769fc61a1db10078/46604/greedy.png","srcSet":"/static/cdd912ffc0119bc7769fc61a1db10078/62d80/greedy.png 125w,\n/static/cdd912ffc0119bc7769fc61a1db10078/e1953/greedy.png 250w,\n/static/cdd912ffc0119bc7769fc61a1db10078/46604/greedy.png 500w,\n/static/cdd912ffc0119bc7769fc61a1db10078/d8815/greedy.png 750w,\n/static/cdd912ffc0119bc7769fc61a1db10078/31987/greedy.png 1000w,\n/static/cdd912ffc0119bc7769fc61a1db10078/e4d72/greedy.png 1280w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","C"]},"rawMarkdownBody":"\n## 그리디 알고리즘 개념\n그리디 알고리즘(탐욕법)은 **현재 상황에서 지금 당장 좋은 것만** 고르는 방법을 의미한다.\n**일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구합니다.**\n\n### 작동 방식\n그리디 알고리즘은 다음과 같은 단계로 동작합니다.\n\n1. 문제를 하위 문제로 나눕니다.\n2. 각 하위 문제에 대해 가장 좋아 보이는 선택을 합니다.\n3. 선택한 해를 부분해 집합에 추가합니다.\n4. 부분해 집합이 최종 해답이 되는지 확인합니다.\n5. 만약 최종 해답이 아니라면, 2단계로 돌아가 반복합니다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/da8b64eb-e2fc-47fb-99b5-5f2413e4f365/image.png)\n\n### 장단점\n그리디 알고리즘의 주요 장점은 다음과 같습니다.\n\n1. 구현이 비교적 간단하다.\n2. 실행 속도가 빠르다.\n\n하지만 그리디 알고리즘은 항상 최적해를 구할 수 있는 것은 아닙니다. 최적해를 보장하기 위해서는 추가적인 검증 단계가 필요할 수 있습니다. 그리디 알고리즘은 각 단계에서의 선택이 최적일 뿐, 그 선택들이 전체적으로 최적인지 보장하지 않기 때문입니다. 따라서 그리디 알고리즘을 사용할 때에는 문제의 성질과 제약 조건을 분석하여 최적해를 보장할 수 있는지 판단해야 합니다.\n\n## 예시\n\n### 문제: 거스름돈 문제\n\n> 당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리의 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.\n\n\n#### 해결 방법:\n\n동전의 최소 개수를 구해야 하는 문제이기 때문에, **가장 큰 화폐 단위부터 돈을 거슬러 주는 것**입니다.\n\n거스름 돈이 N원일 때, `500원`으로 최대한 많이 거슬러주고, 순서대로 `100원`, `50원`, `10원`을 써서 거슬러주면 됩니다.\n\n이제 N이 1,260 일 때의 예시를 확인해봅시다.\n\n# 코드\n\n```\n#include <stdio.h>\n\nvoid giveChange(int amount) {\n    int coins[] = {500, 100, 50, 10};  // 동전 종류\n    int numCoins = sizeof(coins) / sizeof(coins[0]);  // 동전 종류의 개수\n    int count[numCoins];  // 동전 개수를 저장할 배열\n\n    // 각 동전의 개수 초기화\n    for (int i = 0; i < numCoins; i++) {\n        count[i] = 0;\n    }\n\n    // 가장 큰 동전부터 시작하여 거스름돈 주기\n    for (int i = 0; i < numCoins; i++) {\n        while (amount >= coins[i]) {\n            amount -= coins[i];\n            count[i]++;\n        }\n    }\n\n    // 거스름돈 출력\n    for (int i = 0; i < numCoins; i++) {\n        if (count[i] > 0) {\n            printf(\"%d원 동전: %d개\\n\", coins[i], count[i]);\n        }\n    }\n}\n\nint main() {\n    int amount = 1260;  // 거스름돈 금액\n    giveChange(amount);\n    return 0;\n}\n\n```\n\n# 정당성 분석\n\n가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까요?\n\n- 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문\n\nQ) 만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500원, 400원, 100원이라면 어떻게 될까요?\n\n- 4개의 동전 / 2개의 동전\n\n**대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수있어야 답을 도출할 수 있다.**"},{"id":"07549a5f-1215-5908-b0ce-13d89002a299","excerpt":"DFS 루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하고 넘어가는 방법. 넓게(wide) 탐색하기 전에 깊게(deep) 탐색한다.모든 노드를 방문 하고자 하는 경우에 이 방법을 사용한다.\n 보다 좀 더 간단하다.단순 검색 속도 자체는 BFS…","fields":{"slug":"/DFS와 BFS/"},"frontmatter":{"title":"DFS와 BFS","date":"2023.05.15","thumbnail":{"publicURL":"/static/b8ff6dc0a1e900b190c9d40910300f12/DFS AND BFS.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoklEQVR42l3STUuUURgG4GvG0ZIZHW2GGccZp7TJGT+SKVQyTaQPIWoVQRKRCNGuMoQ2gS2MIFpIu2gVLoL6A/2DWgW1alEt+gftW7xx5n2t6IZznodz7vN83OeBRTzGFFxiNkNVgis4QAoZsb2F+8huUEYxoaY6ex9dSAf/K8UhGgs0PlCIECXkFJnLsT9QJBeRO0MbzV3/4HNir9KcZGYBk5insclMlGTO0B3sKF4w3KYVku1hnBEMdgIlVXQvMb3M0XC2hBLF1ThgJnDyScCAY7TG4rv+iOLLWK7Wp33CVieJ3HVqO1SCBFu0nlG4zeg3UofpfovXHHpCfZvqOyq/yM/FOvZ2VkR6lsXTDGH4Giez9J+nfYGePuY+xu2kAneeU2uMrzMR9NuL3028p1zkhDcMrFN5Tn2DrqfUgm7fk+qjv3J3Wl+lskbhB+VHHImovaL0k/zNoMxZ5sLX52ncoTrN1INY5D/oJb0Zf051g+N3aZ+j1GI0R2E/8cXgLJMTj052hYNhkm6Q9V+FX+jZob7C4D3Gdhl5SFPC3Y6r9xtWAUcUds4EfgAAAABJRU5ErkJggg==","aspectRatio":2.272727272727273,"src":"/static/b8ff6dc0a1e900b190c9d40910300f12/46604/DFS%20AND%20BFS.png","srcSet":"/static/b8ff6dc0a1e900b190c9d40910300f12/62d80/DFS%20AND%20BFS.png 125w,\n/static/b8ff6dc0a1e900b190c9d40910300f12/e1953/DFS%20AND%20BFS.png 250w,\n/static/b8ff6dc0a1e900b190c9d40910300f12/46604/DFS%20AND%20BFS.png 500w,\n/static/b8ff6dc0a1e900b190c9d40910300f12/d8815/DFS%20AND%20BFS.png 750w,\n/static/b8ff6dc0a1e900b190c9d40910300f12/31987/DFS%20AND%20BFS.png 1000w,\n/static/b8ff6dc0a1e900b190c9d40910300f12/ed396/DFS%20AND%20BFS.png 2000w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","Python"]},"rawMarkdownBody":"\n# DFS\n\n**루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하고 넘어가는 방법.** 넓게(wide) 탐색하기 전에 **깊게(deep)** 탐색한다.**모든 노드를 방문 하고자 하는 경우**에 이 방법을 사용한다.\n`DFS가` `BFS`보다 좀 더 간단하다.단순 검색 속도 자체는 BFS에 비해서 느리다.\n스택이나 재귀 함수를 통해서 구현할 수 있는데 재귀 함수가 구현이 간편하므로 대부분 재귀 함수로 구현한다.\n\n- 구현할 때 주의할 점 : 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사 해야 한다.\n  - 이를 검사하지 않을 경우 무한루프에 빠질 위험이 있다.\n\n### DFS 알고리즘 구현방식\n\n![](https://velog.velcdn.com/images/minseok0123/post/be4be19c-dce2-4c21-9d57-b499d69f729e/image.png)\n\n1. a 노드(시작 노드)를 방문\n\n- 방문한 노드는 방문했다고 체크한다!\n\n2. a와 인접한 노드들을 차례로 순회\n\n- a와 인접한 노드가 없다면 종료\n\n3. a와 이웃한 노드 b를 방문했다면, a와 인접한 또 다른 노드를 방문하기 전에 b의 이웃 노드들을 전부 방문해야 한다.\n\n- b를 시작 정점으로 DFS를 다시 시작하여 b의 이웃 노드들을 방문한다.\n\n4. b의 분기를 전부 완벽하게 탐색했다면 다시 a에 인접한 정점들 중에서 아직 방문이 안 된 정점을 찾는다.\n\n- 즉, b의 분기를 전부 완벽하게 탐색한 뒤에야 a의 다른 이웃 노드를 방문할 수 있다는 뜻이다.\n- 아직 방문이 안 된 정점이 없으면 종료\n- 있으면 다시 그 정점을 시작 정점으로 DFS를 시작!\n\n```python\nvoid search(Node root) {\n  if (root == null) return;\n\n  // 1. root 노드 방문\n  visit(root);\n  root.visited = true; // 1-1. 방문한 노드를 표시\n\n  // 2. root 노드와 인접한 정점을 모두 방문\n  for each (Node n in root.adjacent) {\n    if (n.visited == false) { // 4. 방문하지 않은 정점을 찾는다.\n      search(n); // 3. root 노드와 인접한 정점 정점을 시작 정점으로 DFS를 시작\n    }\n  }\n}\n```\n\n---\n\n```python\ngraph = [[0],\n         [2, 3, 8],\n         [1, 7],\n         [1, 4, 5],\n         [3, 5],\n         [3, 4],\n         [7],\n         [2, 6, 8],\n         [1, 7]]\n\nvisited = [False] * 9\ndef dfs(v, graph, visited):\n    visited[v] = True\n    print(v, end=\" \")\n    for node in graph[v]:\n        if not visited[node]:\n            dfs(node, graph, visited)\n\n\ndfs(1, graph, visited)\n```\n\n### DFS의 장점\n\n- 현재 경로상의 노드들만 기억하면 되므로, 저장 공간의 수요가 비교적 적음\n- 목표 노드가 깊은 단계에 있는 경우 해를 빨리 구할 수 있음\n- 구현이 너비 우선 탐색(BFS) 보다 간단함\n\n### DFS의 단점\n\n- 단순 검색 속도는 너비 우선 탐색(BFS) 보다 느림\n- 해가 없는 경우에 빠질 가능성이 있음(사전에 임의의 깊이를 지정한 후 탐색하고, 목표 노드를 발견하지 못할 경우 다음 경로를 탐색하도록 함)\n- 깊이 우선 탐색은 해를 구하면 탐색이 종료되므로, 구한 해가 최단 경로가 된다는 보장이 없음(목표에 이르는 경로가 다수인 경우 구한 해가 최적이 아닐 수 있음)\n\n### DFS의 시간 복잡도\n\n- DFS는 그래프(정점의 수: N, 간선의 수: E)의 모든 간선을 조회한다.\n  - 인접 리스트로 표현된 그래프: O(N+E)\n  - 인접 행렬로 표현된 그래프: O(N^2)\n\n# BFS\n\n그래프 전체를 탐색하는 방법 중 하나.루트 노드 (혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법.시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회방법.종이에 먹물이 퍼지는 것과 같음.즉, 깊게(deep) 탐색하기 전에 넓게(wide) 탐색한다 !BFS가 진행될수록 탐색 범위는 출발점에서 멀어진다.\n주로 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 사용하는 방법이다.(최단 경로, 길찾기)방문한 노드들을 차례대로 저장한 후 꺼낼 수 있는 자료구조인 Queue를 사용한다.\n\n### queue\n\nQueue는 **선입선출(FIFO, Fisrt In First Out)** 자료구조.먼저 들어온 것이 먼저 나간다.고속도로 톨게이트를 생각하자.\n\n- 특징\n  - 재귀적으로 동작하지 않는다.\n  - 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.\n  - 검사하지 않을 경우 무한루프에 빠질 위험이 있다.\n- 장점\n  - 로직이 단순하다.\n  - 최초 발견 루트를 최단 경로라고 보장할 수 있다.\n  - 노드의 숫자가 적고, 깊이가 얕은 경우 -> 단순검색속도가 DFS보다 빠르다.\n- 단점\n  - 비교적 많은 저장 공간이 필요하다.\n\n### BFS 알고리즘 구현방식\n\n**큐**를 활용해서 구현.\n![](https://velog.velcdn.com/images/minseok0123/post/e38ad96a-db7a-47cf-a9fd-4f82318c78c6/image.png)\n\n1. a 노드(시작 노드)를 방문. (방문한 노드 체크)\n\n- 큐에 방문한 노드를 삽입. `enqueue`\n- 초기 상태의 큐에는 시작 노드만 저장되어 있다.\n  - 즉, a노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다 !\n\n2. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례대로 방문.\n\n- 큐에서 꺼낸 노드를 방문\n- 큐에서 꺼낸 노드와 인접한 노드들을 방문\n  - 인접한 노드가 없다면 큐의 앞에서 노드를 꺼낸다. `dequeue`\n- 큐에 방문된 노드를 삽입. `enqueue`\n\n3. 큐가 다 소진될 때까지 계속 반복.\n\n```python\nvoid search(Node root) {\n  Queue queue = new Queue();\n  root.marked = true; // (방문한 노드 체크)\n  queue.enqueue(root); // 1-1. 큐의 끝에 추가\n\n  // 3. 큐가 소진될 때까지 계속한다.\n  while (!queue.isEmpty()) {\n    Node r = queue.dequeue(); // 큐의 앞에서 노드 추출\n    visit(r); // 2-1. 큐에서 추출한 노드 방문\n    // 2-2. 큐에서 꺼낸 노드와 인접한 노드들을 모두 차례로 방문한다.\n    foreach (Node n in r.adjacent) {\n      if (n.marked == false) {\n        n.marked = true; // (방문한 노드 체크)\n        queue.enqueue(n); // 2-3. 큐의 끝에 추가\n      }\n    }\n  }\n}\n```\n\n```python\nlet bfs = function (node) {\n    // TODO: 노드의 탐색을 treeBFS 탐색 순으로 배열에 담아내자\n    let result = [];\n    let queue = [node]; // 조회할 노드를 순차적으로 넣는다.\n\n    // 조회할 노드가 없을때까지\n    while (queue.length) {\n        let target = queue.shift();\n        result.push(target.value);\n        // 자식 노드들을 순차적으로 queue에 쌓아준다.\n        for (let node of root.children) {\n            queue.push(node);\n        }\n\n    }\n    return result;\n};\nlet Node = function (value) {\n    this.value = value;\n    this.children = [];\n};\n\n// 위 Node 객체로 구성되는 트리는 매우 단순한 형태의 트리.\n// membership check(중복 확인)를 따로 하지 않는다.\nNode.prototype.addChild = function (child) {\n    this.children.push(child);\n    return child;\n};\n```\n\n---\n\n```python\nfrom collections import deque\n\nvisited = [False] * 9\ngraph = [[0],\n         [2, 3, 8],\n         [1, 7],\n         [1, 4, 5],\n         [3, 5],\n         [3, 4],\n         [7],\n         [2, 6, 8],\n         [1, 7]]\n\nq = deque()\n\ndef bfs(start, graph, visited):\n    visited[start] = True\n    q.append(start)\n\n    while q:\n        v = q.popleft()\n        print(v, end=\" \")\n        for i in graph[v]:\n            if not visited[i]:\n                q.append(i)\n                visited[i] = True\n\nbfs(1, graph, visited)\n```\n\n### BFS의 장점\n\n- 노드의 수가 적고 깊이가 얕은 경우 빠르게 동작할 수 있다.\n- 단순 검색 속도가 DFS보다 빠르다.\n- 최단 경로가 존재한다면 어느 한 경로가 무한히 깊어진다고 해도 최단 경로를 반드시 찾을 수 있다.\n\n### BFS의 단점\n\n- 노드의 수가 늘어나면 탐색해야 하는 노드 또한 많아지기 때문에 비현실적이다.\n- 재귀호출의 DFS와는 달리 다음에 탐색할 정점들을 큐에 저장해야 하므로 저장공간이 많이 필요하다.\n\n### BFS의 시간 복잡도\n\n- 인접 리스트로 표현된 그래프 : `O(N+E)`\n- 인접 행렬로 표현된 그래프 : `O(N^2)`\n\n## 마지막 정리\n\n> DFS (깊이 우선 탐색): 트리나 그래프에서 한 노드의 자식들을 우선으로 탐색하는 방식. 더 이상 자식이 없을 때까지 계속해서 깊이를 우선으로 내려가며 탐색한다.\n\n> BFS (너비 우선 탐색): 트리나 그래프에서 한 노드의 형제들을 우선으로 탐색하는 방식. 같은 레벨에 있는 노드들을 먼저 탐색한 후, 다음 레벨로 이동한다.\n\n> DFS는 스택 또는 재귀 함수를 이용하여 구현할 수 있으며, BFS는 큐를 이용하여 구현할 수 있다.\n"},{"id":"aa0169f6-77cb-5507-b2e0-4418d1075102","excerpt":"순차탐색알고리즘 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법 주로, 정렬되지 않는 리스트에서 데이터를 하나씩 차례대로 확인하는 방법 리스트 내에 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 원소(데이터)를 찾을 수 있다는 장점 리스트에 특정 원소가 있는 지 체크할 경우, 리스트에서 특정한 값을 가지는 원소의 개수를 세는 count…","fields":{"slug":"/탐색알고리즘/"},"frontmatter":{"title":"탐색알고리즘","date":"2023.06.17","thumbnail":{"publicURL":"/static/3f7fbd3be95364da1f101e9494b3be1c/탐색알고리즘.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACj0lEQVR42iXLyVLaAACA4TxWZ3rqph60LghioUhkUYmEsBMSsy8IJqABkwCRJSxZgYp9vw7Tme/wX35gUM0vmZon1pdUyeVq/+0aZdX7SuUskzpIYhGoX0DrUejqIET9juVD4dDeRWjvAnA42ibqPsf4Ir1RWl5HfO8r75q87b1+DKcz9knI0wbbHDKPTJlSCYaPg+DRbg5+CQJzEl01+LXIewLuiLgrN3yl6b00HZm3202HkWy5o+NC5QqZ4JJcJC/3Q4GvwfPvwdPPAcCiaYsillTJ4bF1S/QE3BKp9UBdG5qnKZ6i2E15wUlLVpIu8/fn0VwAvPkWzR1F0EAEsHBaLyI9ufM2WgwNc/I2Gw8NQ9PGurrUB+bryNUX78/mVlv87Zvb1/FHZ94tSNc/ArH9ILBtd3y26Uqy/7SzUhT3SfSaDbtBe3J7wbccTl5Jio0/ug/SCBXwCPLr4Prw02lkLwRsHlseL7iC6Lbamxdl01P9Rsdvd1fdV0/V7SfNFntLtDEjeQNn5RKGJrLx42T+LKxmEoDNMi7JurTgc8IfpjVDSKfG6Zm8UaxMSrhdEOcQ6eb5SbHqkMS6QToEMy8RffhWg9KARTIOtZsnpaKWQBb3zBKhpjCm3uY0MGdBjIMIoxziUqTL1tdYw80JRgJNHV6mfoYBE8VNFLdwWonBnXBOj5YHyeogXdPi1UkMd4vCJPOgIXfzKjqBUAfmxiAmRjLZkzAciAIqjIzKdS1dpo9vxAA0vsO0eLkLIv1U9S32MMoS0yJhoYxT4xyEm91hAwR+hlJGDhmlUaCVvNXvS+hJvHAYn2cpI4H24qUuWBCC2eENpt/UTJiaQoQF0/P0wwgqL/GaX+FMkDBB/B+NUXKz7GaGwwAAAABJRU5ErkJggg==","aspectRatio":1.6025641025641026,"src":"/static/3f7fbd3be95364da1f101e9494b3be1c/46604/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png","srcSet":"/static/3f7fbd3be95364da1f101e9494b3be1c/62d80/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 125w,\n/static/3f7fbd3be95364da1f101e9494b3be1c/e1953/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 250w,\n/static/3f7fbd3be95364da1f101e9494b3be1c/46604/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 500w,\n/static/3f7fbd3be95364da1f101e9494b3be1c/d8815/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 750w,\n/static/3f7fbd3be95364da1f101e9494b3be1c/31987/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 1000w,\n/static/3f7fbd3be95364da1f101e9494b3be1c/e4d72/%ED%83%90%EC%83%89%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98.png 1280w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","Python"]},"rawMarkdownBody":"\n# 순차탐색알고리즘\n\n리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법\n\n- 주로, 정렬되지 않는 리스트에서 데이터를 하나씩 차례대로 확인하는 방법\n- 리스트 내에 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 원소(데이터)를 찾을 수 있다는 장점\n- 리스트에 특정 원소가 있는 지 체크할 경우, 리스트에서 특정한 값을 가지는 원소의 개수를 세는 count() 메서드 이용할 경우\n\n```python\n#순차 탐색 코드\n\ndef sequentail_search(n,target,array):\n  #각 원소를 하나씩 확인하며\n  for i in range(n):\n    #현재의 원소가 찾고자 하는 원소가 동일한 경우\n    if array[i] == target:\n      return i+1 #현재의 위치 변환(인덱스는 0부터 시작하므로 1더하기)\n\nprint('생성할 원소 개수를 입력한 다음 한 칸 띄고 찾을 문자열을 입력하세요.')\ninput_data = input().split()\nn = int(input_data[0]) #원소의 개수\ntarget = input_data[1] #찾고자 하는 문자열\n\nprint('앞서 적은 원소 개수만큼 문자열을 입력하세요. 구분은 띄어쓰기 한 칸으로 합니다.')\narray = input().split()\n\n#순차 탐색 수형결과 출력\nprint(sequentail_search(n,target,array))\n```\n\n# 이진탐색알고리즘\n\n- 이진 탐색: 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법\n  - 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정한다\n\n## 이진 탐색 동작 예시\n\n- 이미 정렬된 10개의 데이터 중에서 값이 4인 원소를 찾는 예시를 살펴보자\n  ![](https://velog.velcdn.com/images/minseok0123/post/9ba4721a-c960-4925-97e8-a80eddcc3d55/image.png)\n- **[Step 1]** 시작점: 0, 끝점: 9, 중간점: 4 (소수점 이하 제거)\n  ![](https://velog.velcdn.com/images/minseok0123/post/9d2823ae-177e-4255-a268-c10f29e78f5a/image.png)\n- **[Step 2]** 시작점:0, 끝점: 3, 중간점: 1 (소수점 이하 제거)\n  ![](https://velog.velcdn.com/images/minseok0123/post/77cef67b-a7df-427c-99e0-957112c3655f/image.png)\n- **[Step 3]** 시작점: 2, 끝점: 3, 중간점: 2 (소수점 이하 제거)\n  ![](https://velog.velcdn.com/images/minseok0123/post/b8a1ff21-c596-470b-9264-9bd14ecd401d/image.png)\n\n---\n\n## 이진 탐색의 시간 복잡도\n\n- 단계마다 탐색 범위를 2로 나누는 것과 동일하므로 연산 횟수는 log₂𝑁에 비례한다\n- 예를 들어 초기 데이터 개수가 32개일 때, 이상적으로 1단계를 거치면 16개가량의 데이터만 남는다\n  - 2단계를 거치면 8개가량의 데이터만 남는다\n  - 3단계를 거치면 4개가량의 데이터만 남는다\n\n---\n\n```python\n# 이진 탐색 소스코드 구현 (재귀 함수)\ndef binary_search(array, target, start, end):\n    if start > end:\n        return None\n    mid = (start + end) // 2\n    # 찾은 경우 중간점 인덱스 반환\n    if array[mid] == target:\n        return mid\n    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인\n    elif array[mid] > target:\n        return binary_search(array, target, start, mid - 1)\n    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인\n    else:\n        return binary_search(array, target, mid + 1, end)\n\n# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기\nn, target = list(map(int, input().split()))\n# 전체 원소 입력 받기\narray = list(map(int, input().split()))\n\n# 이진 탐색 수행 결과 출력\nresult = binary_search(array, target, 0, n - 1)\nif result == None:\n    print(\"원소가 존재하지 않습니다\")\nelse:\n    print(result + 1)\n```\n\n```python\n# 이진 탐색 소스코드 구현 (반복문)\ndef binary_search(array, target, start, end):\n    while start <= end:\n        mid = (start + end) // 2\n        # 찾은 경우 중간점 인덱스 반환\n        if array[mid] == target:\n            return mid\n        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인\n        elif array[mid] > target:\n            end = mid - 1\n        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인\n        else:\n            start = mid + 1\n    return None\n\n# n(원소의 개수)과 target(찾고자 하는 값)을 입력 받기\nn, target = list(map(int, input().split()))\n# 전체 원소 입력 받기\narray = list(map(int, input().split()))\n\n# 이진 탐색 수행 결과 출력\nresult = binary_search(array, target, 0, n - 1)\nif result == None:\n    print(\"원소가 존재하지 않습니다.\")\nelse:\n    print(result + 1)\n```\n\n## 마지막 정리\n\n**_이진 탐색_**\n\n- 정렬된 배열에서 중간 값을 비교하여 탐색 범위를 반씩 줄여가며 원하는 값을 찾는 알고리즘.\n- 시간 복잡도는 O(log n)으로 매우 효율적이지만, 배열이 정렬되어 있어야 한다는 제약이 있다.\n- 이진 탐색은 반복문 또는 재귀적으로 구현할 수 있다.\n\n_**순차 탐색**_\n\n- 배열이나 리스트와 같은 선형 구조에서 처음부터 끝까지 원하는 값을 찾을 때 사용하는 간단한 탐색 알고리즘.\n- 시간 복잡도는 O(n)으로 배열의 크기에 비례하여 선형적으로 증가한다.\n- 배열이나 리스트의 크기가 작거나 정렬되지 않은 경우에 유용하게 사용될 수 있다.\n"},{"id":"4a7fcc04-390f-5cbc-8d48-4472857c23e8","excerpt":"다이나믹 프로그래밍 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함 다이나믹 프로그래밍의 구현은 일반적으로 **두 가지 방식(탑다운과 보텀업)**으로 구성 다이나믹 프로그래밍은 동적 계획법이라고도 부름 일반적인 프로그래밍 분야에서의 동적(Dynamic…","fields":{"slug":"/다이나믹 프로그래밍/"},"frontmatter":{"title":"다이나믹 프로그래밍","date":"2023.06.18","thumbnail":{"publicURL":"/static/4fd18ad7d6fe83b8aaf4c639d01365bc/다이나믹 프로그래밍.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACnklEQVR42j2N+U/acADF+zdobb/f3i2UlrYUJDgUYXIJHgG8kOI5EM9scsx5RN3mFBcny+bcZvxBt0QTdRrvZP/ewliWfH54Ly/vPWTYq8ZccsguB3WpxSp6FCnpUbIBpU2Xn9pVj011SLJDknVJ0kS5hm6xaqKsiBbkda9jo0f7kNT3cqGDQur8feH7jPdkc+ysMnf2NX+6++J0d/nXu+y3uc7D8tLe4lQlF3sVVQtRbSakIp8H7fvD+lHGflEMXm/nbrbS1+v+u0/jD0fzt8ezt8ez9wezV+We65LvYiNzsT50Mt/+zVDLcWkhZEbKUbYSE/YT5iNDOJ92Peyv3pWzjxvx+53k2bbx+8vo4/bgzUr3w8fiyeJQJcpWIkQ5CJd8RLGVREoeuBYgtqe6tvKD5UKqUkofro0fr6ZOtiYOltOXb43LNeNqLXO6MvlzIfPj5ehxcWxnoi/fQuZbSMRjgkELGW8UikZXPhFYGYmV+gJbI+1v0uFC3Ls64Nt81rkQb11Jd5R6/JPhxud9kW6H6Je5VpFFRAJaKehvcg73xJId4YHOSCIcyKX6x5L9+emJjJHKGKlkRzjZFe2NhBLhkJGINTt0TTApvIAIEKgcaxN4h9lsE3iN52wC65QsDlFwK5LbKugmwS6wKkerHKtyrMIwMstZaJoBADFRVfMXRiQpC01baNpMkFaaVhnCp3AMAArDSAxtov6lJoriIcUBEgH1DRQOYANKA4KDkMYwniB4oqr9KmPjSIhiNAZoDDA4QWB4VQOiWkExxMyyXqfW5rJ7G/Ww2zngc7okAdQ34HVoRCUZAGrrDF4t1BBImocUTxCIXbb0+p4kQ+6U35XtbE0Hm2LNGgdxvA518pBEUQZgHIQQxf5Tu6Vw8AcQ/74lfblC+QAAAABJRU5ErkJggg==","aspectRatio":1.6025641025641026,"src":"/static/4fd18ad7d6fe83b8aaf4c639d01365bc/46604/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png","srcSet":"/static/4fd18ad7d6fe83b8aaf4c639d01365bc/62d80/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 125w,\n/static/4fd18ad7d6fe83b8aaf4c639d01365bc/e1953/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 250w,\n/static/4fd18ad7d6fe83b8aaf4c639d01365bc/46604/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 500w,\n/static/4fd18ad7d6fe83b8aaf4c639d01365bc/d8815/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 750w,\n/static/4fd18ad7d6fe83b8aaf4c639d01365bc/31987/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 1000w,\n/static/4fd18ad7d6fe83b8aaf4c639d01365bc/e4d72/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.png 1280w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘","Python"]},"rawMarkdownBody":"\n# 다이나믹 프로그래밍\n\n- 다이나믹 프로그래밍은 **메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법**\n- **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장**하여 다시 계산하지 않도록 함\n- 다이나믹 프로그래밍의 구현은 일반적으로 **두 가지 방식(탑다운과 보텀업)**으로 구성\n- 다이나믹 프로그래밍은 **동적 계획법**이라고도 부름\n- 일반적인 프로그래밍 분야에서의 동적(Dynamic)이란 어떤 의미를 가질까?\n  - 자료구조에서 **동적 할당(Dynamic Allocation)**은 **'프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'**을 의미\n  - 반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어\n- 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 떄 사용 가능\n  - **최적 부분 구조 (Optimal Substructure)**\n    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있음\n  - **중복되는 부분 문제 (Overlapping Subproblem)**\n    - 동일한 작은 문제를 반복적으로 해결해야 함\n\n### 피보나치 수열\n\n- **피보나치 수열**은 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산 가능\n  - 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n- **점화식**이란 **인접한 항들 사이의 관계식**을 의미\n- 피보나치 수열을 점화식으로 표현하면 다음과 같음\n  - `a(n) = a(n-1) + a(n-2)`\n  - `a(1) = 1, a(2) = 1`\n- 피보나치 수열이 계산되는 과정은 다음과 같이 표현할 수 있음 - 프로그래밍에서는 이러한 수열을 **배열이나 리스트를 이용**해 표현\n  ![](https://velog.velcdn.com/images/minseok0123/post/799c3a2e-fcea-4414-9c29-040c9c308a24/image.png)\n- 피보나치 수열이 계산되는 과정은 다음과 같이 표현할 수 있음\n  - n번째 피보나치 수를 f(n)라고 할 때 4번째 피보나치 수 f(4)를 구하는 과정은 다음과 같음\n\n![](https://velog.velcdn.com/images/minseok0123/post/565e15b7-596c-45ca-b7a6-5d39691794c8/image.png)\n\n```python\n# 피보나치 함수(Fibonacci Function)을 재귀함수로 구현\ndef fibo(x):\n    if x == 1 or x == 2:\n        return 1\n    return fibo(x - 1) + fibo(x - 2)\n\nprint(fibo(4))\n\n>>> 3\n```\n\n### 피보나치 수열의 시간 복잡도 분석\n\n- 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됨\n- 다음과 같이 f(2)가 여러번 호출되는 것을 확인할 수 있음 (중복되는 부분 문제)\n\n![](https://velog.velcdn.com/images/minseok0123/post/d0be3388-35c6-4aa8-ae6a-e13509a3455b/image.png)\n\n- 피보나치 수열의 시간 복잡도는 다음과 같음\n  - 세타 표기법: 𝜃(1.618⋯ᴺ)\n  - 빅오 표기법: O(2ᴺ)\n- 빅오 표기법을 기준으로 f(30)을 계산하기 위해 약 10억가량의 연산을 수행해야 함\n\n### 피보나치 수열의 효율적인 해법: 다이나믹 프로그래밍\n\n- **다이나믹 프로그래밍의 사용 조건**을 만족하는지 확인\n  - **최적 부분 구조**: 큰 문제를 작은 문제로 나눌 수 있음\n  - **중복되는 부분 문제**: 동일한 작은 문제를 반복적으로 해결\n- 피보나치 수열은 다이나믹 프로그래밍의 사용 조건을 만족\n\n### 메모이제이션 (Memoization)\n\n- **메모이제이션**은 다이나믹 프로그래밍을 구현하는 방법 중 하나 (**탑다운 방식=하향식**)\n- **한 번 계산한 결과를 메모리 공간에 메모하는 기법**\n  - 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옴\n  - 값을 기록해 놓는다는 점에서 **캐싱(Caching)**이라고도 함\n\n### 탑다운 vs 보텀업\n\n- **탑다운(메모이제이션) 방식**은 **하향식**이라고도 하며 **보텀업 방식**은 **상향식**이라고도 함\n- **다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식**\n  - **결과 저장용 리스트는 DP 테이블**이라고 부름\n- 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미\n  - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님\n  - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음\n\n---\n\n```python\n# 피보나치 수열: 탑다운 다이나믹 프로그래밍 소스코드\n\n# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화\nd = [0] * 100\n\n# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)\ndef fibo(x):\n    # 종료 조건(1 혹은 2일 때 1을 반환)\n    if x == 1 or x == 2:\n        return 1\n    # 이미 계산한 적 있는 문제라면 그대로 반환\n    if d[x] != 0:\n        return d[x]\n    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환\n    d[x] = fibo(x - 1) + fibo(x - 2)\n    return d[x]\n\nprint(fibo(99))\n\n>>> 218922995834555169026\n```\n\n---\n\n```python\n# 피보나치 수열: 보텀업 다이나믹 프로그래밍 소스코드\n\n# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화\nd = [0] * 100\n\n# 첫번째 피보나치 수와 두번째 피보나치 수는 1\nd[1] = 1\nd[2] = 2\nn = 99\n\n# 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)\nfor i in range(3, n + 1):\n    d[i] = d[i - 1] + d[i - 2]\n\nprint(d[n])\n\n>>> 218922995834555169026\n```\n\n### 피보나치 수열: 메모이제이션 동작 분석\n\n- 이미 계산된 결과를 메모리에 저장하면 다음과 같이 색칠된 노드만 처리할 것을 기대할 수 있음\n\n![](https://velog.velcdn.com/images/minseok0123/post/d4af10cd-c6b6-4d7a-af51-cc6b68e5b5fa/image.png)\n\n- 실제로 호출되는 함수에 대해서만 확인해보면 다음과 같이 방문\n\n![](https://velog.velcdn.com/images/minseok0123/post/d2fdc836-cabe-4f8f-8f03-ce46d370e185/image.png)\n\n- 메모이제이션을 이용하는 경우 피보나치 수열 함수의 시간 복잡도는 O(N)\n\n```\nd = [0] * 100\n\ndef fibo(x):\n    print('f(' + str(x) + ')', end=' ')\n    if x == 1 or x == 2:\n        return 1\n    if d[x] != 0:\n        return d[x]\n    d[x] = fibo(x - 1) + fibo(x - 2)\n    return d[x]\n\nfibo(6)\n\n>>>> f(6) f(5) f(4) f(3) f(2) f(1) f(2) f(3) f(4)\n```\n\n### 다이나믹 프로그래밍 vs 분할 정복\n\n- **다이나믹 프로그래밍**과 **분할 정복**은 **모두 최적 부분 구조를 가질 때 사용 가능**\n  - **큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황**\n- 다이나믹 프로그래밍과 분할 정복의 **차이점**은 **부분 문제의 중복**\n  - 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복\n  - 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않음\n- **분할 정복**의 대표적인 예시로 **퀵 정렬**이 있음\n  - 한 번 기준 원소(Pivot)가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지 않음\n  - 분할 이후에 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않음\n\n![](https://velog.velcdn.com/images/minseok0123/post/1ba8ff89-f534-4403-b637-016a9041b75d/image.png)\n\n### 다이나믹 프로그래밍 문제에 접근하는 방법\n\n- 주어진 문제가 **다이나믹 프로그래밍 유형임을 파악**하는 것이 중요\n- 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있음\n  - 다른 알고리즘으로 풀이 방법이 떠오르지 않는다면 다이나믹 프로그래밍을 고려\n- 일단 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 코드를 개선하는 방법을 사용할 수 있음\n- 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많음\n\n## 마지막 정리\n\n> 다이나믹 프로그래밍(Dynamic Programming)은 문제를 작은 부분 문제로 나누어 해결하고, 중복 계산을 피하여 효율적으로 최적해를 구하는 알고리즘 기법이다. 주어진 문제를 작은 부분 문제로 쪼갠 후 하향식(Top-down) 메모이제이션 기법이나 상향식(Bottom-up) 반복적인 계산 기법을 사용하여 최적해를 구한다.\n"},{"id":"eef22044-29c8-5dca-9531-08bfcd10c1d5","excerpt":"1. 기획의도 웹을 통해 기숙사 방 문을 원격으로 쉽게 열 수 있습니다. 일과시간 내에 외부 출입자를 감지하고, 해당 정보를 기록할 수 있습니다. 기숙사의 온도와 습도를 실시간으로 모니터링할 수 있습니다. 2. 프로젝트 구성 하드웨어 구성 1. 모션 감지 센서: 사람의 출입을 감지하고, 해당 출입시간을 데이터베이스에 기록합니다. 학교의 일과시간 중에 출입이 감지되면 부저를 울리고 웹으로 경고 메시지를 전송합니다.…","fields":{"slug":"/ESP32로 만든 스마트 기숙사 시스템/"},"frontmatter":{"title":"ESP32로 만든 스마트 기숙사 시스템","date":"2023.06.20","thumbnail":{"publicURL":"/static/28647871d9e4c8d77b2e3dd8245a493a/ESP32.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAPoAAAD6AG1e1JrAAACe0lEQVR42hXO3U7aUAAA4GZeKFShp6ftac8p9JSWQis4FUEFwZ9KKSioc5rNoYlz6AU4NXHBJct24eKyqHEPYLJkybJd+ArzYt7IWy37nuBj8EAE9RMYEMLhof6BAY6DCocQL0ZFLITEMMRBqA4CCSHFST+dyuedpIkNNTU5JscJg0KKEBTZYNh1Xc/zstlceAhWXX+x5Na8pWx2quwvl4pz8/Nuvd5o1JfTaScIWKiIyCCMoGIoS5ZlPTz87fV6v3/91DTz8vK6VJi7ufl2fHSyv3+wsOBeXl6VPa97dgZFwHLBEAaAACYQsOPWsO0M39//eXx8/PHjO1Hp+fnnwkyp231/d3fnVaq1Wv3i4svt7e2i74lYJBgOsoFBNsD09SWCYZMa8U8fP1xffT3Yb9GYZTlpMzlMTUvVYhBhmURJlJoJWzN1FEW6EYEQAMAxnBQDGEd1M6pqkoSRhCOa0Vhdq/jVQnF2bt6tr6yWK361tsSLcnYyV3JnV5/VdarplDI8JkBCqmaMjU5kxnOKHKEx6/DtUbvTedXc3t19/Xxj8/j4ZG/vTb5Q7HQOu91uu932i8XM+DiDNMop2DQ0ikHfk35RQJpubm3v7LX2X7zcaja3m82d6fxMq9VaWVkjhDrOcC6Xy2cyoymbUWWiSIRE9KnJaUVRZaRourmwWF5u/N/6taX1jc1y2fP9qudVBEWTaDKVTqftxIgdZygkfEgQJHx6+q7X662vbwIBASXC0yRHdE7CMCJzURjSwsACQNZCxEJJ20nGUnac4XlxkIMkSnUzbliW7ThAjnBYY80JCAUeEd4BAWOAVVguFaKxGEkk9dGRlGWmU8l/t9uJbqkmulUAAAAASUVORK5CYII=","aspectRatio":1.7857142857142858,"src":"/static/28647871d9e4c8d77b2e3dd8245a493a/46604/ESP32.png","srcSet":"/static/28647871d9e4c8d77b2e3dd8245a493a/62d80/ESP32.png 125w,\n/static/28647871d9e4c8d77b2e3dd8245a493a/e1953/ESP32.png 250w,\n/static/28647871d9e4c8d77b2e3dd8245a493a/46604/ESP32.png 500w,\n/static/28647871d9e4c8d77b2e3dd8245a493a/d8815/ESP32.png 750w,\n/static/28647871d9e4c8d77b2e3dd8245a493a/31987/ESP32.png 1000w,\n/static/28647871d9e4c8d77b2e3dd8245a493a/e4d72/ESP32.png 1280w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["아두이노","ESP32","PHP","임베디드"]},"rawMarkdownBody":"\n\n# 1. 기획의도\n- 웹을 통해 기숙사 방 문을 원격으로 쉽게 열 수 있습니다.\n- 일과시간 내에 외부 출입자를 감지하고, 해당 정보를 기록할 수 있습니다.\n- 기숙사의 온도와 습도를 실시간으로 모니터링할 수 있습니다.\n---\n\n# 2. 프로젝트 구성\n## 하드웨어 구성\n### 1. 모션 감지 센서:\n- 사람의 출입을 감지하고, 해당 출입시간을 데이터베이스에 기록합니다.\n- 학교의 일과시간 중에 출입이 감지되면 부저를 울리고 웹으로 경고 메시지를 전송합니다.\n### 2. 온/습도 센서:\n- 기숙사 방 안의 온도와 습도를 실시간으로 측정합니다.\n- 웹에서 실시간으로 이 정보를 확인할 수 있습니다.\n### 3. 서보모터:\n- 웹에서 열림 버튼을 누르면 기숙사 방 내의 서보모터를 제어하여 원격으로 문을 열 수 있습니다.\n### 4. 부저:\n- 정해진 시간 외에 출입이 감지되면 소리를 시끄럽게 울립니다.\n### 5. LCD 디스플레이:\n- 와이파이에 연결되면 IP 주소를 디스플레이에 표시합니다.\n- 온도와 습도 정보를 디스플레이에 표시하여 실시간 모니터링이 가능합니다.\n---\n\n## 소프트웨어 구성\n### DB : MYSQL\n### SERVER : PHP\n### WEB : HTML/CSS/JAVASCRIPT\n---\n### 1. 홈페이지:\n- DB에서 페이지 3개의 최근 값을 가져와 네비게이션에 표시해 줍니다.\n- ajax를 이용해 5초 마다 값을 새로 고침해서 DB에서 실시간으로 값을 불러옵니다.\n![](https://velog.velcdn.com/images/minseok0123/post/ce6d51a7-162e-4eee-8ce9-dc1d4bb7094e/image.png)\n### 2. 기숙사 상태\n- ajax를 이용해 5초 마다 값을 새로 고침해서 DB에서 실시간으로 값을 불러옵니다.\n- 현재 기숙사의 온/습도를 ESP32에서 보낸 값을 DB에 저장하고 불러옵니다.\n![](https://velog.velcdn.com/images/minseok0123/post/fc2c3885-2def-4c92-9d68-2ff59db80bfb/image.png)\n### 3. 출입자 관리\n- 전체 보기를 누르면 입과 출입 여부 상관없이 전체 시간대의 출입 내용을 모두 보여준다.\n- 일과 출입 여부를 누르면 일과시간 출입인 값만 필터링해서 가져온다.\n- 데이터값이 많으면 자동으로 페이지네이션 된다.\n- 최근 업데이트를 만들어서 쉽게 몇 분, 몇 시, 며칠 전에 출입했는지 확인할 수 있다.\n- ajax를 이용해 5초 마다 값을 새로 고침해서 DB에서 실시간으로 값을 불러옵니다.\n![](https://velog.velcdn.com/images/minseok0123/post/0ce3c217-21f9-4d39-a008-a8e482481f81/image.png)\n---\n### 3-1 일과시간 수정\n- 일과시간 수정 버튼을 누르면 일과시간을 수정할 수 있는 모달창이 뜬다.\n- 등교시간/하교시간을 수정하고 저장 버튼을 누르면 ESP32웹 서버에 GET으로 값이 전달된다.\n- DB에도 값이 업데이트 되서 필터링 되는 조건이 변경이 된다.\n![](https://velog.velcdn.com/images/minseok0123/post/21528970-57a0-4aad-9148-8f9087b963f2/image.png)\n\n### 4. 원격제어\n- ESP32 웹 서버에 OPEN이라는 값을 GET으로 넘긴다.\n- 값이 들어오면 서보모터를 작동시킨다.\n![](https://velog.velcdn.com/images/minseok0123/post/e3637ae3-289e-4bb4-91e7-5a8e5b4ab15a/image.png)\n### 5. 로그인\n- 디바이스를 할당하기 위해서 계정이 필요했다.\n- 그래서 로그인/회원가입을 만들기로 했다.\n![](https://velog.velcdn.com/images/minseok0123/post/ac7823d8-5fa9-46df-b8bc-45ff17002a7b/image.png)\n### 6. 회원가입\n- 아이디를 입력하고 중복확인을 누르면 DB에 중복되는 아이디가 있는지 확인하다.\n- 비밀번호를 4자리 이상으로 입력해야 한다. (비밀번호는 해시로 암호화 한다)\n- 회원가입 할 때 ESP32의 웹 서버 IP주소를 입력하면 디바이스가 할당된다.\n- 이메일도 중복되지 않아야지 가입이 된다.\n![](https://velog.velcdn.com/images/minseok0123/post/2d81404b-9864-4b47-a458-219663ecf6ef/image.png)\n\n### 7. 비밀번호 찾기\n- 로그인을 만들면서 만약 비밀번호를 까먹으면 새로 가입해야 하는 번거로움이 생겼다.\n만약 새로 가입하지 않을려면 DB를 직접 수정해야 했다.\n- 그래서 비밀번호 찾기를 만들기로 결정했다.\n- PHP MAILER를 이용해서 이메일로 비밀번호 재설정 코드를 보내줬다.\n![](https://velog.velcdn.com/images/minseok0123/post/50dfb2ec-9d15-4d1b-a8bc-7123679badfb/image.png)\n- 이렇게 재설정 인증 코드가 이메일로 온다.\n![](https://velog.velcdn.com/images/minseok0123/post/dcfe5cc8-3758-45d0-b683-0822becfc991/image.png)\n- 인증 코드를 입력하면가 일치하면 비밀번호가 재설정 된다. \n![](https://velog.velcdn.com/images/minseok0123/post/37c4021a-f665-4385-b74b-e7c97e50f318/image.png)\n---\n# 3. 기대효과\n\n- 1. 웹을 통한 원격 문 열기로 인해 출입의 편의성이 향상됩니다.\n- 2. 외부 출입자의 감지와 출입 기록으로 보안 강화와 출입 관리가 용이해집니다.\n- 3. 기숙사 내 온도와 습도를 실시간으로 모니터링하여 안전하고 편리한 환경을 조성합니다.\n---\n\n# 4. 마무리\n\n> 이 프로젝트는 스마트 기숙사 시스템으로 원격 문 열기와 출입 감지, 온/습도 모니터링 등을 제공합니다. 다양한 센서와 LCD 디스플레이를 활용하여 학생들의 안전과 편의성을 향상시킬 수 있습니다. 이 프로젝트는 현대적인 기술과 창의적인 아이디어를 결합하여 효율적인 기숙사 관리 시스템을 구축하는 데 성공하였습니다.\n\n**GITHUB**\n> https://github.com/MinSeok0123/BSSMSECOM"},{"id":"7a0477ec-6bae-5e88-9b70-97a6d13ed179","excerpt":"…","fields":{"slug":"/최단 경로/"},"frontmatter":{"title":"최단 경로","date":"2023.08.28","thumbnail":{"publicURL":"/static/a75398f78245969eab7384f600e18aac/shortest route.png","childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGElEQVR42oWR227CQAxE+f8vQyoqVCqi6RMgKCoNIZvLbmyP7YpERVQQMU+W18f2eiZ+J3N3EVcNqXlbzGOMDhiz3VVO/JFSaop4DhwPhwOJSFlqXftTWKHL5fsxnC4rMHMbh/zP8ZitVs9g1fVmkzdFHU4MERYzUyCUYb/bARiH2ygi5m5mZHJKIfvMYkpWVQ6omYiMwpISoP3RTEKZx/Ijy4ioTxiAUVhEBpKJ1/tt0dWsEGL/A1RVmP/BZhcLiOh1Nott6+5VFaYv02FgFyovy6EUqlB9MFlV8zzvuosvCq2RznXOXWTo1XxqW++7u9nja1tVQaDQSN13U+y+9sKiABEZ4GN/tl7X2N1jSovFvG2a26db+BcShIUSxpTSrwAAAABJRU5ErkJggg==","aspectRatio":1.7857142857142858,"src":"/static/a75398f78245969eab7384f600e18aac/46604/shortest%20route.png","srcSet":"/static/a75398f78245969eab7384f600e18aac/62d80/shortest%20route.png 125w,\n/static/a75398f78245969eab7384f600e18aac/e1953/shortest%20route.png 250w,\n/static/a75398f78245969eab7384f600e18aac/46604/shortest%20route.png 500w,\n/static/a75398f78245969eab7384f600e18aac/40725/shortest%20route.png 580w","sizes":"(max-width: 500px) 100vw, 500px"}}},"categories":["알고리즘"]},"rawMarkdownBody":"\n# 최단 경로 문제\n\n- 최단 경로 알고리즘은 그래프에서 가장 짧은 경로를 찾는 알고리즘을 의미합니다.\n- 다양한 문제 상황에서 사용될 수 있으며, 주요한 경우는 다음과 같습니다\n\n  - 한 지점에서 다른 한 지점까지의 최단 경로\n  - 한 지점에서 다른 모든 지점까지의 최단 경로\n  - 모든 지점에서 다른 모든 지점까지의 최단 경로\n\n이때, 각 지점은 그래프에서 노드로 표현되며, 지점 간 연결된 도로는 그래프에서 간선으로 표현됩니다.\n\n![](https://velog.velcdn.com/images/minseok0123/post/49fe9c3a-0735-4eab-affb-73df0550e56e/image.png)\n\n# 다익스트라 최단 경로 알고리즘 개요\n\n다익스트라(Dijkstra) 최단 경로 알고리즘은 특정한 노드에서 출발하여 다른 모든 노드까지의 최단 경로를 계산하는 알고리즘입니다. 이 알고리즘은 음의 간선이 없을 때에만 정상적으로 동작하며, 그리디(Greedy) 알고리즘에 속합니다.\n\n## 다익스트라 알고리즘 동작과정\n\n[초기 상태] 그래프를 준비하고 출발 노드를 설정한다\n\n![](https://velog.velcdn.com/images/minseok0123/post/c4c49dbe-5f41-4676-aeef-ba1016dc76c7/image.png)\n\n1. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 1번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/b05ef06c-8348-4c40-9509-9bf90652f803/image.png)\n2. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 4번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/20dd98ef-17ab-4a5c-867a-ace0e7900569/image.png)\n3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 2번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/c2c27133-f178-4c44-ac34-7517bec9ffa1/image.png)\n4. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 5번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/64599945-d9b8-414e-919e-23f11f2ddc5f/image.png)\n5. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 3번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/8877c391-282a-4c06-a571-d95d095cc210/image.png)\n6. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드인 6번 노드를 처리한다\n   ![](https://velog.velcdn.com/images/minseok0123/post/8135d804-4de1-4ac6-a6cd-a721cfeaae4e/image.png)\n\n## 다익스트라 알고리즘의 특징\n\n**그리디 접근 방식**: 다익스트라 알고리즘은 각 단계에서 방문하지 않은 노드 중에서 현재까지의 최단 거리 추정치가 가장 작은 노드를 선택합니다. 이를 통해 임의의 과정을 반복하며 최단 거리를 점진적으로 갱신해 나갑니다.\n\n**최단 거리의 확정**: 알고리즘 수행 중 한 번 처리된 노드의 최단 거리는 더 이상 변경되지 않습니다. 다시 말해, 각 노드에 대한 최단 거리는 점점 정확하게 확정됩니다.\n\n**단계적 접근**: 다익스트라 알고리즘은 각 단계마다 하나의 노드에 대한 최단 거리를 확실히 찾아냅니다. 이러한 접근 방식을 통해 그래프의 모든 노드에 대한 최단 거리를 구할 수 있습니다.\n\n**최단 거리 정보 저장**: 알고리즘을 실행한 뒤에는 각 노드까지의 최단 거리 정보가 테이블에 저장됩니다. 이 정보를 통해 출발 노드로부터 다른 모든 노드까지의 최단 경로와 거리를 쉽게 확인할 수 있습니다.\n"}]}}}