{"componentChunkName":"component---src-templates-post-template-tsx","path":"/그래프 알고리즘/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1 id=\"1-그래프Graph란\" style=\"position:relative;\">1. 그래프(Graph)란?<a href=\"#1-%EA%B7%B8%EB%9E%98%ED%94%84Graph%EB%9E%80\" aria-label=\"1 그래프Graph란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>그래프는 객체들 간의 연결 관계를 나타내는 수학적 구조로, 노드(Node)와 이를 연결하는 간선(Edge)으로 구성됩니다. 그래프는 현실 세계에서의 다양한 상호 관계를 추상화하여 모델링하는 데 사용됩니다.</p>\n<h3 id=\"서로소-집합-자료구조Union-Find\" style=\"position:relative;\">서로소 집합 자료구조(Union-Find)<a href=\"#%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0Union-Find\" aria-label=\"서로소 집합 자료구조Union Find permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>서로소 집합 자료구조는 원소들을 서로 중복되지 않는 부분 집합으로 나누는 데 사용되며, 주로 그래프 내 사이클을 판별하거나 연결성을 확인하는 데 활용됩니다.</p>\n</blockquote>\n<p><strong>주요 동작:</strong></p>\n<ol>\n<li>두 원소의 합집합 연산을 확인하여 두 원소가 속한 그룹을 확인합니다.</li>\n<li>각 그룹의 루트 노드를 찾아 부모 자식 관계를 설정합니다.</li>\n</ol>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/594f36b4-7f9b-450e-adfc-95106e184f22/image.png\" alt=\"\"></p>\n<h4 id=\"서로소-집합을-활용한-사이클-판별\" style=\"position:relative;\">서로소 집합을 활용한 사이클 판별<a href=\"#%EC%84%9C%EB%A1%9C%EC%86%8C-%EC%A7%91%ED%95%A9%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%82%AC%EC%9D%B4%ED%81%B4-%ED%8C%90%EB%B3%84\" aria-label=\"서로소 집합을 활용한 사이클 판별 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>서로소 집합은 무방향 그래프 내의 사이클을 판별하는 데 사용됩니다. 동일한 그룹에 속하는 원소들이 추가로 연결되면 사이클이 발생합니다. 이를 활용하여 그래프 내 사이클 여부를 판별할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">char</span> vect<span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">char</span> <span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> tar<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>vect<span class=\"token punctuation\">[</span>tar<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> tar<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">char</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span>vect<span class=\"token punctuation\">[</span>tar<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ret<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">makeGroup</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">char</span> t1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">char</span> t2<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">char</span> a <span class=\"token operator\">=</span> <span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span>t1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">char</span> b <span class=\"token operator\">=</span> <span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span>t2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">==</span> b<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    vect<span class=\"token punctuation\">[</span>b<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">makeGroup</span><span class=\"token punctuation\">(</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'B'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">makeGroup</span><span class=\"token punctuation\">(</span><span class=\"token char\">'B'</span><span class=\"token punctuation\">,</span> <span class=\"token char\">'C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span><span class=\"token char\">'A'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token function\">getBoss</span><span class=\"token punctuation\">(</span><span class=\"token char\">'C'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"같은그룹\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">else</span>\n    <span class=\"token punctuation\">{</span>\n        cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token string\">\"다른그룹\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n \t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>경로 압축\nchar ret = getBoss(vect[tar]);</p>\n</blockquote>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/474ddbcd-5d72-40de-80cb-e94df9c63913/image.png\" alt=\"\"></p>\n<h1 id=\"2-그래프의-종류\" style=\"position:relative;\">2. 그래프의 종류<a href=\"#2-%EA%B7%B8%EB%9E%98%ED%94%84%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"2 그래프의 종류 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>그래프에는 여러 가지 종류가 있으며, 주로 다음과 같이 분류합니다.</p>\n<p><strong>방향성에 따른 분류:</strong>\n방향 그래프(Directed Graph): 각 간선이 특정 방향을 가진 경우.\n무방향 그래프(Undirected Graph): 각 간선이 방향성을 가지지 않은 경우.\n<strong>가중치 유무에 따른 분류:</strong>\n가중치 그래 프(Weighted Graph) : 각간 선에 가중치 값이 할당된 경우.\n비가중치 그라 프(Unweighted Graph) : 모든간 선의 가중치가 동일한(혹은 없음)경우.\n<strong>연결성에 따른 분류:</strong>\n연결된 그라 프(Connected Graph) : 모든노 드사 이에 경로가 존재하는 경우.\n비연결된그라 프(Disconnected Graph) : 일부노 드사 이에 경로가 존재하지 않음</p>\n<h1 id=\"3-신장-트리\" style=\"position:relative;\">3. 신장 트리<a href=\"#3-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC\" aria-label=\"3 신장 트리 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>신장 트리는 그래프에서 모든 노드를 포함하면서 사이클이 없는 부분 그래프를 의미합니다.</p>\n<h2 id=\"최소-신장-트리-MST-크루스칼-알고리즘\" style=\"position:relative;\">최소 신장 트리 (MST, 크루스칼 알고리즘)<a href=\"#%EC%B5%9C%EC%86%8C-%EC%8B%A0%EC%9E%A5-%ED%8A%B8%EB%A6%AC-MST-%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"최소 신장 트리 MST 크루스칼 알고리즘 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최소한의 비용으로 신장트리를 찾고싶을 때 사용한다.</p>\n<p>최소 신장 트리는 그래프 내에서 가장 적은 비용으로 모든 노드를 연결하는 트리를 찾는 알고리즘입니다. 크루스칼 알고리즘은 이러한 최소 신장 트리를 구하는 데 사용되며, 그리디 알고리즘에 속합니다. 모든 간선을 가중치 순으로 정렬한 후, 작은 가중치부터 간선을 트리에 추가하는 방식으로 동작합니다. 이때, 서로 연결된 노드의 부모를 찾기 위해 서로소 집합 자료구조를 활용합니다.</p>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/5e4a6323-46fe-4071-9b99-4f9a45983669/image.png\" alt=\"\"></p>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/50da0122-10d6-461c-8278-5bfadafc88e1/image.png\" alt=\"\"></p>\n<blockquote>\n<p>최종적으로 신장 트리에 포함되는 간선의 개수가 ‘노드의 개수 - 1’ 과 같다.</p>\n</blockquote>\n<h1 id=\"4-위상-정렬\" style=\"position:relative;\">4. 위상 정렬<a href=\"#4-%EC%9C%84%EC%83%81-%EC%A0%95%EB%A0%AC\" aria-label=\"4 위상 정렬 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>위상 정렬은 방향 그래프에서 노드들을 순서대로 나열하는 알고리즘입니다. 이때, 간선은 방향을 따르며 노드 간의 의존 관계를 나타냅니다. 위상 정렬은 선행 관계를 만족하는 작업의 순서를 찾는 데 사용됩니다.</p>\n<p>위상 정렬 알고리즘</p>\n<blockquote>\n<ol>\n<li>진입차수가 0 인 노드를 큐에 넣는다.</li>\n<li>큐가 빌 때까지 다음의 과정을 반복한다.\nI. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.\nII. 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.</li>\n</ol>\n</blockquote>\n<p>진입차수란 -> 특정한 노드로 <strong>들어오는</strong> 간선의 개수를 의미한다.</p>\n<p><img src=\"https://velog.velcdn.com/images/minseok0123/post/c06a7dc4-4e4f-472f-92ce-cf8642f20a93/image.png\" alt=\"\"></p>\n<p>참고로, 위상정렬의 답안은 여러가지가 될 수 있다. (한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상일 경우)</p>","frontmatter":{"title":"그래프 알고리즘","summary":"그래프는 객체 간의 네트워크를 모델링하는데 사용되는 수학적 구조입니다. 노드(Node)라 불리우는 개체와 이들을 연결하는 간선(Edge)으로 구성됩니다.","date":"2023.08.29","categories":["알고리즘","C++"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/033c3fd924832fdd40f362828c9081b3/30ad0/graph.png","srcSet":"/static/033c3fd924832fdd40f362828c9081b3/fa343/graph.png 200w,\n/static/033c3fd924832fdd40f362828c9081b3/76288/graph.png 400w,\n/static/033c3fd924832fdd40f362828c9081b3/30ad0/graph.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/033c3fd924832fdd40f362828c9081b3/316eb/graph.webp 200w,\n/static/033c3fd924832fdd40f362828c9081b3/494da/graph.webp 400w,\n/static/033c3fd924832fdd40f362828c9081b3/d3e80/graph.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":338}},"publicURL":"/static/033c3fd924832fdd40f362828c9081b3/graph.png"}}}}]}},"pageContext":{"slug":"/그래프 알고리즘/"}},"staticQueryHashes":[],"slicesMap":{}}